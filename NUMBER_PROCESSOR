import os
import re
import csv
import math
from datetime import datetime
import dataiku

# -----------------------------
# Weighted keyword lists
# -----------------------------
APPROVER_KEYWORDS = {
    "approved": 100, "granted": 95, "confirmed": 90, "accepted": 90,
    "authorized": 95, "approve": 80, "confirm": 80, "accept": 80,
    "approval": 50, "clearance": 70, "endorsed": 75, "signed off": 85,
    "cleared": 80, "validated": 85, "ratified": 90, "sanctioned": 90
}

REQUESTER_KEYWORDS = {
    "request": 100, "require": 95, "seek approval": 90, "need approval": 90,
    "asking": 80, "petition": 75, "approval": 30, "pending": 60,
    "remind": 70, "follow up": 65, "submitted": 85, "application": 80,
    "awaiting": 75, "petition": 70, "seeking": 85
}

# -----------------------------
# Helper functions
# -----------------------------
def split_emails(raw_text):
    parts = re.split(r"(?=^From: )", raw_text, flags=re.IGNORECASE | re.MULTILINE)
    if parts and not parts[0].strip().lower().startswith("from:"):
        first = parts.pop(0)
        parts = [first] + parts
    return parts

def extract_field(email, field):
    pattern = rf"{field}:(.*)"
    match = re.search(pattern, email, re.IGNORECASE)
    return match.group(1).strip() if match else ""

def parse_date_time(date_str):
    if not date_str:
        return None
    try:
        return datetime.strptime(date_str.strip(), "%A, %B %d, %Y %I:%M %p")
    except Exception:
        return None

def extract_body(email):
    split_point = re.search(r"\n\s*\n", email)
    return email[split_point.end():].strip() if split_point else ""

def clean_participant_name(raw_name):
    if not raw_name:
        return ""
    cleaned = re.sub(r'<[^>]+>', '', raw_name)
    cleaned = re.sub(r'[;"\']', '', cleaned)
    cleaned = ' '.join(cleaned.split()).strip()
    cleaned = cleaned.rstrip(',')
    return cleaned

def find_matching_statement(email_body, keywords):
    sentences = re.split(r'(?<=[.!?])\s+', email_body.strip())
    matches = []
    for sentence in sentences:
        s_lower = sentence.lower()
        for kw in keywords:
            if kw in s_lower:
                matches.append(sentence.strip())
    return "; ".join(matches)

def subject_keyword_score(subject, keywords, weight=10):
    score = 0
    if not subject:
        return 0
    subject_lower = subject.lower()
    for kw in keywords:
        if kw in subject_lower:
            score += weight
    return score

def simple_positional_weight(position, total_emails):
    if total_emails <= 1:
        return 0.5, 0.5
    normalized_pos = position / (total_emails - 1)
    return 1 - normalized_pos, normalized_pos  # requester, approver

def adjust_cc_bcc_score(sender, cc_list, bcc_list, current_score):
    if sender in cc_list or sender in bcc_list:
        current_score *= 0.8
    return current_score

# -----------------------------
# Parsing & scoring
# -----------------------------
def parse_email_chain(text):
    email_chunks = split_emails(text)
    parsed = []

    for i, email in enumerate(email_chunks):
        sender = extract_field(email, "From")
        receiver = extract_field(email, "To")
        cc = extract_field(email, "Cc")
        bcc = extract_field(email, "Bcc")
        subject = extract_field(email, "Subject")
        date_raw = extract_field(email, "Sent")

        dt = parse_date_time(date_raw)
        date_str = dt.date().isoformat() if dt else ""
        time_str = dt.time().isoformat() if dt else ""

        body = extract_body(email)
        approval_statement = find_matching_statement(body, APPROVER_KEYWORDS.keys())
        request_statement = find_matching_statement(body, REQUESTER_KEYWORDS.keys())

        parsed.append({
            "Email Sequence": i + 1,
            "Sender": sender,
            "Receiver": receiver,
            "cc": cc,
            "bcc": bcc,
            "subject": subject,
            "email body": body,
            "approval statement": approval_statement,
            "request statement": request_statement,
            "datetime": dt,
            "date": date_str,
            "time": time_str
        })

    parsed = sorted(parsed, key=lambda x: x["datetime"] if x["datetime"] else datetime.min)
    for i, email in enumerate(parsed):
        email["Email Sequence"] = i + 1
    return parsed

def extract_all_participants(parsed_emails):
    participants = set()
    for email in parsed_emails:
        sender = clean_participant_name(email["Sender"])
        if sender: participants.add(sender)
        receivers = [clean_participant_name(r) for r in email["Receiver"].split(',') if email["Receiver"]]
        participants.update([r for r in receivers if r])
        cc = [clean_participant_name(c) for c in email["cc"].split(',')] if email["cc"] else []
        participants.update([c for c in cc if c])
        bcc = [clean_participant_name(b) for b in email["bcc"].split(',')] if email["bcc"] else []
        participants.update([b for b in bcc if b])
    return sorted(participants)

def calculate_role_scores(parsed_emails):
    role_scores = {}
    total_emails = len(parsed_emails)
    first_email = min(parsed_emails, key=lambda x: x["datetime"] if x["datetime"] else datetime.max)
    first_sender = clean_participant_name(first_email["Sender"])

    for i, email in enumerate(parsed_emails):
        sender = clean_participant_name(email["Sender"])
        if not sender: continue
        body = email["email body"].lower()
        subject = email["subject"].lower() if email["subject"] else ""
        cc_list = [clean_participant_name(c) for c in email["cc"].split(',')] if email["cc"] else []
        bcc_list = [clean_participant_name(b) for b in email["bcc"].split(',')] if email["bcc"] else []

        if sender not in role_scores:
            role_scores[sender] = {"approver": 0, "requester": 0, "details": []}

        # Keyword scores
        req_keyword_score = sum([REQUESTER_KEYWORDS.get(k, 0) for k in REQUESTER_KEYWORDS if k in body])
        app_keyword_score = sum([APPROVER_KEYWORDS.get(k, 0) for k in APPROVER_KEYWORDS if k in body])

        # Subject scores
        req_subject_score = subject_keyword_score(subject, REQUESTER_KEYWORDS.keys())
        app_subject_score = subject_keyword_score(subject, APPROVER_KEYWORDS.keys())

        # Temporal / positional weight
        pos_weight_req, pos_weight_app = simple_positional_weight(i, total_emails)

        # Combined score
        req_score = (req_keyword_score + req_subject_score) * pos_weight_req
        app_score = (app_keyword_score + app_subject_score) * pos_weight_app

        # Adjust for CC/BCC
        req_score = adjust_cc_bcc_score(sender, cc_list, bcc_list, req_score)
        app_score = adjust_cc_bcc_score(sender, cc_list, bcc_list, app_score)

        role_scores[sender]["requester"] += req_score
        role_scores[sender]["approver"] += app_score
        role_scores[sender]["details"].append(f"Req score: {req_score:.1f}, App score: {app_score:.1f}")

    return role_scores, first_sender

def identify_requester_approver(parsed_emails):
    scores, first_sender = calculate_role_scores(parsed_emails)

    potential_approvers = [(s, data["approver"]) for s, data in scores.items() if s != first_sender and data["approver"] > 0]
    potential_approvers.sort(key=lambda x: x[1], reverse=True)

    potential_requesters = [(s, data["requester"]) for s, data in scores.items() if data["requester"] > 0]
    potential_requesters.sort(key=lambda x: x[1], reverse=True)

    approver = potential_approvers[0][0] if potential_approvers else ""
    requester = first_sender if any(s == first_sender for s, _ in potential_requesters) else (potential_requesters[0][0] if potential_requesters else "")

    if not approver and potential_requesters:
        for email in reversed(parsed_emails):
            sender = clean_participant_name(email["Sender"])
            if sender != requester and sender != first_sender:
                approver = sender
                scores[approver]["approver"] += 50
                scores[approver]["details"].append("+50 fallback last sender")
                break

    return requester, approver, scores, first_sender

# -----------------------------
# Dataiku folder I/O
# -----------------------------
def save_to_csv(parsed_emails, output_folder_path, output_file="parsed_emails.csv"):
    output_path = os.path.join(output_folder_path, output_file)
    fieldnames = parsed_emails[0].keys()
    with open(output_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(parsed_emails)
    print(f"✅ CSV saved: {output_path}")

def save_summary(parsed_emails, scores, output_folder_path, summary_file="summary_output.txt"):
    output_path = os.path.join(output_folder_path, summary_file)
    requester, approver, _, first_sender = identify_requester_approver(parsed_emails)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("=== ROLE ANALYSIS SUMMARY ===\n")
        f.write(f"First Sender (can't be approver): {first_sender}\n")
        f.write(f"Identified Requester: {requester}\n")
        f.write(f"Identified Approver: {approver}\n\n")
        f.write("=== DETAILED SCORE BREAKDOWN ===\n")
        for sender, score_data in scores.items():
            f.write(f"\nSender: {sender}\n")
            f.write(f"Total Approver Score: {score_data['approver']}\n")
            f.write(f"Total Requester Score: {score_data['requester']}\n")
            f.write("Score Components:\n")
            for detail in score_data["details"]:
                f.write(f"  - {detail}\n")
    print(f"✅ Summary saved: {output_path}")

def create_user_role_mapping(parsed_emails, requester, approver):
    participants = extract_all_participants(parsed_emails)
    role_mapping = []
    for p in participants:
        if p == requester:
            role = "Requester"
        elif p == approver:
            role = "Approver"
        else:
            role = "Participant"
        role_mapping.append({"Name": p, "Role": role})
    return role_mapping

def save_user_roles_to_csv(role_mapping, output_folder_path, filename="Email_Users.csv"):
    output_path = os.path.join(output_folder_path, filename)
    with open(output_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=["Name", "Role"])
        writer.writeheader()
        writer.writerows(role_mapping)
    print(f"✅ User roles saved: {output_path}")

# -----------------------------
# Main Dataiku workflow
# -----------------------------
def main(input_folder_code, output_folder_code, input_file="email_text.txt"):
    input_folder = dataiku.Folder(input_folder_code)
    output_folder = dataiku.Folder(output_folder_code)

    input_path = os.path.join(input_folder.get_path(), input_file)
    if not os.path.exists(input_path):
        print(f"❌ File not found: {input_path}")
        return

    with open(input_path, "r", encoding="utf-8") as f:
        email_text = f.read()

    parsed_emails = parse_email_chain(email_text)
    if not parsed_emails:
        print("❌ No emails parsed.")
        return

    output_path = output_folder.get_path()

    save_to_csv(parsed_emails, output_path)
    requester, approver, scores, first_sender = identify_requester_approver(parsed_emails)
    save_summary(parsed_emails, scores, output_path)
    role_mapping = create_user_role_mapping(parsed_emails, requester, approver)
    save_user_roles_to_csv(role_mapping, output_path)

    print("\n🔍 Identified Roles:")
    print(f"First Sender: {first_sender}")
    print(f"Requester: {requester}")
    print(f"Approver: {approver}")

# -----------------------------
# Example execution in DSS
# -----------------------------
if __name__ == "__main__":
    INPUT_FOLDER_CODE = "MY_INPUT_FOLDER"
    OUTPUT_FOLDER_CODE = "MY_OUTPUT_FOLDER"
    main(INPUT_FOLDER_CODE, OUTPUT_FOLDER_CODE)
