import pandas as pd
import zipfile
import os
import tempfile
import openpyxl
import csv
from datetime import datetime
import dataiku

def setup_dataiku_folders(input_folder_id, output_folder_id):
    """
    Set up Dataiku folder connections
    Returns: input_folder, output_folder objects
    """
    try:
        client = dataiku.api_client()
        project = dataiku.default_project()
        
        input_folder = project.get_folder(input_folder_id)
        output_folder = project.get_folder(output_folder_id)
        
        print(f"Connected to input folder: {input_folder_id}")
        print(f"Connected to output folder: {output_folder_id}")
        
        return input_folder, output_folder
        
    except Exception as e:
        print(f"Error connecting to Dataiku folders: {e}")
        raise

def download_zip_files(input_folder, temp_dir):
    """
    Download ZIP files from Dataiku folder to temporary directory
    """
    downloaded_files = []
    
    try:
        # List all files in the input folder
        folder_contents = input_folder.list_paths_in_partition()
        
        for file_path in folder_contents:
            if file_path.lower().endswith('.zip'):
                # Get the file name
                file_name = os.path.basename(file_path)
                local_path = os.path.join(temp_dir, file_name)
                
                # Download the file
                input_folder.download(file_path, local_path)
                downloaded_files.append(local_path)
                print(f"✓ Downloaded: {file_name}")
                
    except Exception as e:
        print(f"Error downloading ZIP files: {e}")
        
    return downloaded_files

def extract_zip_files(zip_files, extract_dir):
    """
    Extract ZIP files to temporary directory
    """
    extracted_files = []
    
    for zip_path in zip_files:
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)
                extracted_files.extend([
                    os.path.join(extract_dir, name) for name in zip_ref.namelist()
                ])
                print(f"✓ Extracted: {os.path.basename(zip_path)}")
                
        except Exception as e:
            print(f"✗ Error extracting {zip_path}: {e}")
            
    return extracted_files

def validate_excel(file_path, issues):
    """
    Validate Excel file using the same logic as original code
    """
    try:
        wb = openpyxl.load_workbook(file_path, data_only=True)
        
        # Check if "COMPUTED DATA" sheet exists
        if "COMPUTED DATA" not in wb.sheetnames:
            issues.append([
                os.path.basename(file_path), 
                "N/A", 
                "Missing 'COMPUTED DATA' sheet"
            ])
            return
            
        ws = wb["COMPUTED DATA"]
        date = ws.cell(row=16, column=2).value if ws.cell(row=16, column=2).value else "N/A"

        # Check last status (case-insensitive)
        def get_last_status(ws):
            status_rows = []
            for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=1):
                if row[0].value and str(row[0].value).strip().lower() == "status":
                    status_rows.append(row[0].row)
            if status_rows:
                last_status_row = status_rows[-1]
                last_status_val = ws.cell(row=last_status_row, column=2).value
                return last_status_val
            return None

        last_status_val = get_last_status(ws)
        if not last_status_val or str(last_status_val).strip().lower() != "submitted":
            issues.append([
                os.path.basename(file_path), 
                date, 
                "Last status is not Submitted"
            ])

        df_labels = [
            "DF1- Direct Relevant Transactions",
            "DF2- Related Relevant Transactions",
            "DF3- Market Transactions",
            "DF4- Broker Quotes",
            "DF5- Expert Judgement"
        ]
        
        def find_row(ws, label):
            for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=1):
                if row[0].value and label in str(row[0].value):
                    return row[0].row
            return None
            
        priority_rows = [find_row(ws, label) for label in df_labels]
        chosen_rate_row = find_row(ws, "Chosen Rate")
        final_rate_row = find_row(ws, "Final Rate")
        rational_row = find_row(ws, "Rational for Proposing the Adjustment")

        for col in range(2, ws.max_column + 1):
            tenor = ws.cell(row=2, column=col).value
            if not tenor:  # Skip empty columns
                continue
                
            # Find the highest priority DF value
            priority_val = None
            priority_label = None
            for idx, row in enumerate(priority_rows):
                if row is not None:
                    val = ws.cell(row=row, column=col).value
                    if val != "N/A" and val is not None:
                        priority_val = val
                        priority_label = df_labels[idx]
                        break
                        
            chosen_rate = ws.cell(row=chosen_rate_row, column=col).value if chosen_rate_row else None
            final_rate = ws.cell(row=final_rate_row, column=col).value if final_rate_row else None
            rational_val = ws.cell(row=rational_row, column=col).value if rational_row else None

            # Step 1: Chosen Rate should match highest priority DF value
            if priority_val is not None and chosen_rate != priority_val:
                error_message = f"Chosen Rate ({chosen_rate}) does not match highest priority DF value ({priority_val}) from {priority_label} for tenor {tenor}"
                if rational_val not in [None, "", "N/A"]:
                    error_message += f". Rational provided: {rational_val}"
                issues.append([
                    os.path.basename(file_path), date, error_message
                ])
            # Step 2: Only if Chosen Rate matches DF value, check Final Rate
            elif priority_val is not None and chosen_rate == priority_val and final_rate != chosen_rate:
                issues.append([
                    os.path.basename(file_path), date,
                    f"Chosen Rate ({chosen_rate}) does not match Final Rate ({final_rate}) for tenor {tenor}"
                ])
            # Step 3: Rational should be empty only if there is a mismatch
            elif priority_val is not None and chosen_rate != priority_val and rational_val not in [None, "", "N/A"]:
                if not any("Rational for Proposing the Adjustment is not empty" in issue[2] for issue in issues):
                    issues.append([
                        os.path.basename(file_path), date,
                        f"Rational for Proposing the Adjustment is not empty for tenor {tenor}"
                    ])
                    
    except Exception as e:
        issues.append([
            os.path.basename(file_path),
            "N/A",
            f"Error processing file: {str(e)}"
        ])

def process_extracted_excels(extracted_files, output_folder):
    """
    Process all extracted Excel files and generate error reports
    """
    issues = []
    
    # Filter for Excel files
    excel_files = [f for f in extracted_files if f.lower().endswith(('.xlsx', '.xls', '.xlsm'))]
    
    print(f"\n--- Processing {len(excel_files)} Excel files ---")
    
    for excel_file in excel_files:
        try:
            validate_excel(excel_file, issues)
        except Exception as e:
            print(f"Error processing {excel_file}: {e}")

    # Generate error reports
    if issues:
        print(f"Found {len(issues)} issues across all files")
        
        # Create error report files in memory/temp
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8') as csv_temp:
            csv_path = csv_temp.name
            writer = csv.writer(csv_temp)
            writer.writerow(["File Name", "Date", "Reason"])
            for row in issues:
                writer.writerow(row)
        
        with tempfile.NamedTemporaryFile(mode='wb', suffix='.xlsx', delete=False) as excel_temp:
            excel_path = excel_temp.name
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Error Report"
            ws.append(["File Name", "Date", "Reason"])
            for row in issues:
                ws.append(row)
            wb.save(excel_path)
        
        # Upload reports to Dataiku
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        try:
            output_folder.upload(excel_path, f"error_report_{timestamp}.xlsx")
            output_folder.upload(csv_path, f"error_report_{timestamp}.csv")
            print(f"✓ Uploaded error reports to Dataiku folder")
        except Exception as e:
            print(f"✗ Error uploading reports: {e}")
        
        # Clean up temp files
        os.unlink(csv_path)
        os.unlink(excel_path)
    else:
        print("✓ No issues found in any Excel files")

def main():
    """
    Main function to process ZIP files from Dataiku folder
    """
    # Configuration - Update these with your actual Dataiku folder IDs
    INPUT_FOLDER_ID = "input_zip_files"  # Folder containing ZIP files
    OUTPUT_FOLDER_ID = "output_reports"  # Folder for error reports
    
    # Create temporary directories for processing
    with tempfile.TemporaryDirectory() as temp_dir:
        extract_dir = os.path.join(temp_dir, "extracted")
        os.makedirs(extract_dir, exist_ok=True)
        
        try:
            # Set up Dataiku folder connections
            input_folder, output_folder = setup_dataiku_folders(INPUT_FOLDER_ID, OUTPUT_FOLDER_ID)
            
            # Download ZIP files from Dataiku
            print("\n--- Downloading ZIP files from Dataiku ---")
            zip_files = download_zip_files(input_folder, temp_dir)
            
            if not zip_files:
                print("No ZIP files found in input folder")
                return
            
            # Extract ZIP files
            print("\n--- Extracting ZIP files ---")
            extracted_files = extract_zip_files(zip_files, extract_dir)
            
            if not extracted_files:
                print("No files extracted from ZIP archives")
                return
            
            # Process Excel files and generate reports
            process_extracted_excels(extracted_files, output_folder)
            
            print(f"\n--- Process Complete. Processed {len(zip_files)} ZIP files ---")
            
        except Exception as e:
            print(f"Error in main process: {e}")
            raise

if __name__ == "__main__":
    main()
