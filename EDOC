import dataiku
import extract_msg
import pandas as pd
import tempfile
import shutil
import os
import sys
from datetime import datetime

# -----------------------------
# CONFIGURATION
# -----------------------------
INPUT_FOLDER_ID = "YOUR_INPUT_FOLDER_ID"
OUTPUT_FOLDER_ID = "YOUR_OUTPUT_FOLDER_ID"

input_folder = dataiku.Folder(INPUT_FOLDER_ID)
output_folder = dataiku.Folder(OUTPUT_FOLDER_ID)

# -----------------------------
# LOGGING
# -----------------------------
def log(message):
    print(f"[LOG] {message}", file=sys.stderr, flush=True)

# -----------------------------
# EXTRACT EMAIL DETAILS
# -----------------------------
def extract_msg_details(msg_file_path):
    """
    Extract main email details from a .msg file and any nested .msg attachments recursively.
    Returns a list of dictionaries, one per email.
    """
    emails = []
    
    try:
        msg = extract_msg.Message(msg_file_path)
        msg_sender = msg.sender or ""
        msg_to = msg.to or ""
        msg_cc = msg.cc or ""
        msg_bcc = msg.bcc or ""
        msg_subject = msg.subject or ""
        msg_date = msg.date or ""
        msg_body = msg.body or ""
        attachments = []
        
        # Check for nested .msg attachments
        for att in msg.attachments:
            if att.longFilename.lower().endswith(".msg"):
                # Save to temp file and process recursively
                with tempfile.NamedTemporaryFile(suffix=".msg", delete=False) as tmp_att_file:
                    att.save(tmp_att_file.name)
                    emails.extend(extract_msg_details(tmp_att_file.name))
                    os.remove(tmp_att_file.name)
            else:
                attachments.append(att.longFilename)
        
        email_data = {
            "Sender": msg_sender,
            "To": msg_to,
            "CC": msg_cc,
            "BCC": msg_bcc,
            "Subject": msg_subject,
            "Date": msg_date,
            "Body": msg_body,
            "Attachments": ", ".join(attachments),
            "Filename": os.path.basename(msg_file_path),
            "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        emails.insert(0, email_data)  # first email
        msg.close()
        return emails
    
    except Exception as e:
        log(f"❌ Error processing {os.path.basename(msg_file_path)}: {str(e)}")
        return [{
            "Sender": "",
            "To": "",
            "CC": "",
            "BCC": "",
            "Subject": "ERROR_PROCESSING_FILE",
            "Date": "",
            "Body": f"Error: {str(e)}",
            "Attachments": "",
            "Filename": os.path.basename(msg_file_path),
            "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "Error": str(e)
        }]

# -----------------------------
# MAIN PROCESS
# -----------------------------
def main():
    try:
        log("🔍 Searching for .msg files in input folder...")
        all_files = input_folder.list_paths_in_partition()
        msg_files = [f for f in all_files if f.lower().endswith(".msg")]

        if not msg_files:
            log("❌ No .msg files found.")
            return

        log(f"📧 Found {len(msg_files)} .msg file(s) to process")
        
        for msg_path in msg_files:
            file_name = os.path.basename(msg_path)
            log(f"📨 Processing: {file_name}")
            
            try:
                # Download .msg to temp
                with tempfile.NamedTemporaryFile(suffix=".msg", delete=False) as tmp_msg:
                    tmp_msg_path = tmp_msg.name
                    with input_folder.get_download_stream(msg_path) as stream:
                        shutil.copyfileobj(stream, tmp_msg)
                
                # Extract all emails (including nested)
                all_emails = extract_msg_details(tmp_msg_path)
                
                # Convert to DataFrame
                df = pd.DataFrame(all_emails)
                
                # Output CSV filename
                output_csv_name = file_name.replace(".msg", ".csv")
                
                # Save CSV to temp and upload
                with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8-sig', newline='') as tmp_csv:
                    df.to_csv(tmp_csv, index=False)
                    tmp_csv_path = tmp_csv.name
                
                with open(tmp_csv_path, 'rb') as f:
                    output_folder.upload_stream(output_csv_name, f)
                
                # Clean up temp files
                os.remove(tmp_msg_path)
                os.remove(tmp_csv_path)
                
                log(f"✅ Completed: {file_name} -> {output_csv_name} ({len(all_emails)} email(s))")
            
            except Exception as e:
                log(f"❌ Failed to process {file_name}: {str(e)}")
                
        log("📊 All files processed.")

    except Exception as e:
        log(f"🔥 Fatal error: {str(e)}")
        raise

# -----------------------------
# EXECUTE
# -----------------------------
if __name__ == "__main__":
    main()
