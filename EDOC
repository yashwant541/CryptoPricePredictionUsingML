import dataiku
import extract_msg
import pandas as pd
import tempfile
import shutil
import os
import sys
import re
from datetime import datetime
from email.utils import parsedate_to_datetime

# -----------------------------
# CONFIGURATION
# -----------------------------
INPUT_FOLDER_ID = "YOUR_INPUT_FOLDER_ID"
OUTPUT_FOLDER_ID = "YOUR_OUTPUT_FOLDER_ID"

input_folder = dataiku.Folder(INPUT_FOLDER_ID)
output_folder = dataiku.Folder(OUTPUT_FOLDER_ID)

# -----------------------------
# LOGGING
# -----------------------------
def log(message):
    print(f"[LOG] {str(message)}", file=sys.stderr, flush=True)

# -----------------------------
# SAFE STRING FORMATTING
# -----------------------------
def safe_str(obj):
    """Safely convert any object to string"""
    if obj is None:
        return ""
    try:
        return str(obj)
    except:
        return ""

def safe_parse_date(date_string):
    """
    Safely parse email date strings without timezone issues
    """
    date_str = safe_str(date_string)
    if not date_str:
        return ""
    
    try:
        # Try built-in email date parsing
        return parsedate_to_datetime(date_str).strftime("%Y-%m-%d %H:%M:%S")
    except Exception as e:
        try:
            # Fallback: simple string cleaning
            cleaned_date = re.sub(r'\([^)]*\)', '', date_str).strip()
            return cleaned_date
        except:
            return date_str  # Return original if all fails

# -----------------------------
# CONVERT MSG TO TXT (WITH ERROR HANDLING)
# -----------------------------
def msg_to_txt(msg_file_path, txt_file_path):
    """
    Convert .msg file to .txt format with structured content
    """
    msg = None
    try:
        msg = extract_msg.Message(msg_file_path)
        
        with open(txt_file_path, 'w', encoding='utf-8') as txt_file:
            # Write headers in a structured format
            txt_file.write("=== EMAIL HEADERS ===\n")
            txt_file.write(f"From: {safe_str(msg.sender)}\n")
            txt_file.write(f"To: {safe_str(msg.to)}\n")
            txt_file.write(f"CC: {safe_str(msg.cc)}\n")
            txt_file.write(f"BCC: {safe_str(msg.bcc)}\n")
            txt_file.write(f"Subject: {safe_str(msg.subject)}\n")
            txt_file.write(f"Date: {safe_parse_date(msg.date)}\n")
            
            # Try to get message ID safely
            try:
                message_id = safe_str(getattr(msg, 'message_id', ''))
                txt_file.write(f"Message-ID: {message_id}\n")
            except Exception as e:
                txt_file.write("Message-ID: \n")
            
            # Write body
            txt_file.write("\n=== EMAIL BODY ===\n")
            body_content = safe_str(msg.body)
            # Clean up body content
            body_content = re.sub(r'\r\n', '\n', body_content)
            txt_file.write(body_content)
            
            # Write attachments list
            txt_file.write("\n=== ATTACHMENTS ===\n")
            attachments = []
            if hasattr(msg, 'attachments'):
                for att in msg.attachments:
                    try:
                        att_name = safe_str(getattr(att, 'longFilename', 'Unknown'))
                        attachments.append(att_name)
                        txt_file.write(f"{att_name}\n")
                    except Exception as att_error:
                        log(f"‚ö†Ô∏è Attachment error: {str(att_error)}")
                        txt_file.write("Unknown_Attachment\n")
            else:
                txt_file.write("No attachments found\n")
                
        return len(attachments)
        
    except Exception as e:
        log(f"‚ùå Error converting .msg to .txt: {str(e)}")
        # Create error file
        try:
            with open(txt_file_path, 'w', encoding='utf-8') as txt_file:
                txt_file.write(f"ERROR: {str(e)}\n")
        except:
            pass
        return 0
    finally:
        # Ensure message is closed
        if msg:
            try:
                msg.close()
            except:
                pass

# -----------------------------
# PARSE TXT TO STRUCTURED DATA
# -----------------------------
def parse_txt_to_data(txt_file_path, original_filename):
    """
    Parse the generated .txt file back to structured data
    """
    try:
        with open(txt_file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        
        # Initialize data dictionary
        email_data = {
            "Sender": "",
            "To": "",
            "CC": "",
            "BCC": "",
            "Subject": "",
            "Date": "",
            "Body": "",
            "Attachments": "",
            "Filename": safe_str(original_filename),
            "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "Message_ID": ""
        }
        
        # Parse headers section
        headers_section = re.search(r'=== EMAIL HEADERS ===(.*?)=== EMAIL BODY ===', content, re.DOTALL)
        if headers_section:
            headers_text = headers_section.group(1)
            
            # Extract individual headers with safe matching
            def safe_extract(pattern, text, default=""):
                match = re.search(pattern, text)
                return safe_str(match.group(1)).strip() if match else default
            
            email_data["Sender"] = safe_extract(r'From:\s*(.*)', headers_text)
            email_data["To"] = safe_extract(r'To:\s*(.*)', headers_text)
            email_data["CC"] = safe_extract(r'CC:\s*(.*)', headers_text)
            email_data["BCC"] = safe_extract(r'BCC:\s*(.*)', headers_text)
            email_data["Subject"] = safe_extract(r'Subject:\s*(.*)', headers_text)
            email_data["Date"] = safe_extract(r'Date:\s*(.*)', headers_text)
            email_data["Message_ID"] = safe_extract(r'Message-ID:\s*(.*)', headers_text)
        
        # Parse body section
        body_section = re.search(r'=== EMAIL BODY ===(.*?)(=== ATTACHMENTS ===|$)', content, re.DOTALL)
        if body_section:
            email_data["Body"] = safe_str(body_section.group(1)).strip()
        
        # Parse attachments section
        attachments_section = re.search(r'=== ATTACHMENTS ===(.*)', content, re.DOTALL)
        if attachments_section:
            attachments_text = attachments_section.group(1).strip()
            # Clean up attachments list - remove empty lines and join with comma
            attachments_list = [att.strip() for att in attachments_text.split('\n') if att.strip() and att.strip() != "No attachments found"]
            email_data["Attachments"] = ", ".join(attachments_list)
        
        return [email_data]
        
    except Exception as e:
        log(f"‚ùå Error parsing .txt file: {str(e)}")
        return [{
            "Sender": "",
            "To": "",
            "CC": "",
            "BCC": "",
            "Subject": "ERROR_PARSING_TXT",
            "Date": "",
            "Body": f"Error parsing .txt: {str(e)}",
            "Attachments": "",
            "Filename": safe_str(original_filename),
            "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "Error": safe_str(e)
        }]

# -----------------------------
# PROCESS SINGLE MSG FILE (NON-RECURSIVE)
# -----------------------------
def process_single_msg(msg_file_path, original_filename):
    """
    Process a single .msg file without recursive attachment handling
    """
    all_emails = []
    
    # Process the main email by converting to txt and parsing
    with tempfile.NamedTemporaryFile(suffix=".txt", delete=False, mode='w', encoding='utf-8') as tmp_txt:
        tmp_txt_path = tmp_txt.name
    
    try:
        # Convert main message to txt
        msg_to_txt(msg_file_path, tmp_txt_path)
        main_emails = parse_txt_to_data(tmp_txt_path, original_filename)
        all_emails.extend(main_emails)
        
    except Exception as e:
        log(f"‚ùå Error processing {original_filename}: {str(e)}")
        all_emails.append({
            "Sender": "",
            "To": "",
            "CC": "",
            "BCC": "",
            "Subject": "ERROR_PROCESSING_FILE",
            "Date": "",
            "Body": f"Error: {str(e)}",
            "Attachments": "",
            "Filename": safe_str(original_filename),
            "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "Error": safe_str(e)
        })
    finally:
        # Clean up temp file
        try:
            os.unlink(tmp_txt_path)
        except:
            pass
    
    return all_emails

# -----------------------------
# SIMPLIFIED MAIN PROCESS
# -----------------------------
def main():
    try:
        log("üîç Searching for .msg files in input folder...")
        all_files = input_folder.list_paths_in_partition()
        msg_files = [f for f in all_files if f.lower().endswith(".msg")]

        if not msg_files:
            log("‚ùå No .msg files found.")
            return

        log(f"üìß Found {len(msg_files)} .msg file(s) to process")
        
        processed_count = 0
        error_count = 0
        all_data = []
        
        for msg_path in msg_files:
            file_name = os.path.basename(msg_path)
            log(f"üì® Processing: {file_name}")
            
            try:
                # Step 1: Download .msg to temp file
                with tempfile.NamedTemporaryFile(suffix=".msg", delete=False) as tmp_msg:
                    tmp_msg_path = tmp_msg.name
                    with input_folder.get_download_stream(msg_path) as stream:
                        shutil.copyfileobj(stream, tmp_msg)
                
                # Step 2: Process main email (skip nested attachments for now)
                email_data = process_single_msg(tmp_msg_path, file_name)
                all_data.extend(email_data)
                
                # Clean up temp file
                os.unlink(tmp_msg_path)
                
                processed_count += 1
                log(f"‚úÖ Completed: {file_name} -> {len(email_data)} email(s)")
                
            except Exception as e:
                error_count += 1
                log(f"‚ùå Failed to process {file_name}: {str(e)}")
                # Add error record
                all_data.append({
                    "Sender": "",
                    "To": "",
                    "CC": "",
                    "BCC": "",
                    "Subject": "ERROR_FILE_PROCESSING",
                    "Date": "",
                    "Body": f"Failed to process file: {str(e)}",
                    "Attachments": "",
                    "Filename": safe_str(file_name),
                    "Processing_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "Error": safe_str(e)
                })
        
        # Step 3: Save all data to CSV
        if all_data:
            df = pd.DataFrame(all_data)
            
            # Generate output filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_csv_name = f"processed_emails_{timestamp}.csv"
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8-sig', newline='') as tmp_csv:
                df.to_csv(tmp_csv, index=False)
                tmp_csv_path = tmp_csv.name
            
            with open(tmp_csv_path, 'rb') as f:
                output_folder.upload_stream(output_csv_name, f)
            
            os.unlink(tmp_csv_path)
            
            log(f"üìä Saved {len(all_data)} email records to {output_csv_name}")
                
        log(f"üìä Processing complete: {processed_count} successful, {error_count} failed")

    except Exception as e:
        log(f"üî• Fatal error: {str(e)}")
        raise

# -----------------------------
# EXECUTE
# -----------------------------
if __name__ == "__main__":
    main()
