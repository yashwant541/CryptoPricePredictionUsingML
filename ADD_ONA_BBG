import re
import logging
from email.parser import Parser
from email.message import Message
from typing import List, Optional
import sys
import os


class EmailChainProcessor:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        logging.basicConfig(level=logging.INFO)

        self.APPROVAL_PATTERNS = [
            r'\bapproved\b',
            r'\bapproval granted\b',
            r'\brequest approved\b',
            r'\bhas been approved\b',
            r'\byou may proceed\b',
            r'\bgo ahead\b',
            r'\blooks good\b',
            r'\ball good\b',
            r'\bgreen light\b',
            r'\bok to proceed\b',
            r'\bcleared\b'
        ]

        self.REJECTION_PATTERNS = [
            r'\brejected\b',
            r'\bnot approved\b',
            r'\bdeclined\b',
            r'\bcannot approve\b',
            r'\bdenied\b',
            r'\bneed more info\b',
            r'\bi don’t approve\b',
            r'\bit’s not okay\b'
        ]

    def process_email_chain(self, email_body: str) -> dict:
        emails = self._parse_email_chain(email_body)

        if not emails:
            self.logger.warning("No valid emails found in the chain.")
            return {"requester": None, "approver": None, "status": "Unknown"}

        requester, approver = self._identify_requester_approver(emails)
        status = self._determine_approval_status(emails)

        return {
            "requester": requester,
            "approver": approver,
            "status": status
        }

    def _parse_email_chain(self, email_chain: str) -> List[dict]:
        raw_emails = self._split_email_chain(email_chain)
        parsed_emails = []

        for idx, raw_email in enumerate(raw_emails):
            try:
                email_obj = Parser().parsestr(raw_email)
                sender = email_obj.get("From", "")
                to = email_obj.get("To", "")
                subject = email_obj.get("Subject", "")
                date = email_obj.get("Date", "")
                body = self._get_body(email_obj) or raw_email
                parsed_emails.append({
                    "sender": sender.strip(),
                    "to": to.strip(),
                    "subject": subject.strip(),
                    "date": date.strip(),
                    "body": body.strip()
                })
                self.logger.info(f"[Email {idx+1}] Parsed sender: {sender.strip()}")
            except Exception as e:
                self.logger.warning(f"Failed to parse email #{idx+1}: {e}")

        return parsed_emails

    def _split_email_chain(self, text: str) -> List[str]:
        split_patterns = [
            r'(?=^From:)',
            r'(?=^On .*? wrote:)',
            r'(?=^-+ *Original Message *-+)',
            r'(?=^----- Forwarded by)',
        ]

        for pattern in split_patterns:
            parts = re.split(pattern, text, flags=re.MULTILINE | re.IGNORECASE)
            if len(parts) > 1:
                return [p.strip() for p in parts if p.strip()]

        return [text.strip()]

    def _get_body(self, email_obj: Message) -> str:
        if email_obj.is_multipart():
            for part in email_obj.walk():
                if part.get_content_type() == "text/plain":
                    return part.get_payload(decode=True).decode(errors="ignore")
        try:
            return email_obj.get_payload(decode=True).decode(errors="ignore") if email_obj.get_payload() else ""
        except Exception:
            return str(email_obj.get_payload())

    def _identify_requester_approver(self, emails: List[dict]) -> (Optional[str], Optional[str]):
        if not emails:
            return None, None

        requester = emails[0].get("sender")
        approver = None

        for email in emails[1:]:
            if self._contains_approval(email['body']):
                self.logger.info(f"Approval detected from: {email['sender']}")
                approver = email['sender']
                break

        if not approver and len(emails) > 1:
            approver = emails[-1].get("sender")

        return requester, approver

    def _contains_approval(self, text: str) -> bool:
        text = text.lower()
        for pattern in self.APPROVAL_PATTERNS:
            if re.search(pattern, text):
                return True
        return False

    def _contains_rejection(self, text: str) -> bool:
        text = text.lower()
        for pattern in self.REJECTION_PATTERNS:
            if re.search(pattern, text):
                return True
        return False

    def _determine_approval_status(self, emails: List[dict]) -> str:
        for email in reversed(emails):
            if self._contains_rejection(email["body"]):
                return "Rejected"
            if self._contains_approval(email["body"]):
                return "Approved"
        return "Pending"


def main():
    if len(sys.argv) != 2:
        print("Usage: python email_parser.py path/to/email.txt")
        sys.exit(1)

    filepath = sys.argv[1]

    if not os.path.exists(filepath):
        print(f"Error: File '{filepath}' not found.")
        sys.exit(1)

    with open(filepath, "r", encoding="utf-8") as f:
        email_text = f.read()

    processor = EmailChainProcessor()
    result = processor.process_email_chain(email_text)

    print("\n--- Email Chain Summary ---")
    print(f"Requester : {result['requester']}")
    print(f"Approver  : {result['approver']}")
    print(f"Status    : {result['status']}")


if __name__ == "__main__":
    main()
