# recipe_xlsx_safe.py - Dataiku MSG XLSX Extractor (timestamp-safe)
import dataiku
from io import BytesIO
from pathlib import Path
import extract_msg
import traceback

class MSGAttachmentProcessor:
    """
    Extract XLSX attachments from MSG files.
    Completely ignores timestamps and timezones to prevent errors.
    """
    
    def __init__(self, input_folder, output_folder):
        self.input_folder = input_folder
        self.output_folder = output_folder

    def sanitize_filename(self, filename: str) -> str:
        """
        Remove invalid characters from filename
        """
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            filename = filename.replace(char, '_')
        return filename.strip()

    def process_single_msg(self, msg_file_info):
        """
        Process a single MSG file, extracting only XLSX attachments.
        """
        attachments_processed = 0
        attachments_failed = 0

        try:
            msg_name = msg_file_info["path"]
            print(f"Processing MSG file: {msg_name}")

            # Read MSG file bytes
            with self.input_folder.get_download_stream(msg_name) as stream:
                msg_content = stream.read()

            # Open MSG file (no timestamp processing)
            msg_file = BytesIO(msg_content)
            msg = extract_msg.openMsg(msg_file)

            # Only access attachments, never touch msg.date or metadata
            attachments = getattr(msg, 'attachments', [])

            if not attachments:
                print(f"No attachments found in {msg_name}")
                msg.close()
                return attachments_processed, attachments_failed

            print(f"Found {len(attachments)} attachments in {msg_name}")

            # Cache existing output files for duplicate handling
            existing_files = set(self.output_folder.list_paths_in_partition())

            for idx, attachment in enumerate(attachments, 1):
                try:
                    # Only XLSX attachments
                    attachment_name = getattr(attachment, 'filename', f'attachment_{idx}')
                    if not attachment_name.lower().endswith(('.xls', '.xlsx')):
                        print(f"Skipping non-Excel attachment: {attachment_name}")
                        continue

                    clean_name = self.sanitize_filename(attachment_name)
                    base_name = Path(clean_name).stem
                    attachment_data = getattr(attachment, 'data', None)

                    if not attachment_data:
                        raise ValueError("No data found in attachment")

                    # Force XLSX extension
                    file_extension = '.xlsx'

                    # Handle duplicate filenames
                    output_filename = f"{base_name}_{idx}{file_extension}"
                    counter = 1
                    while output_filename in existing_files:
                        output_filename = f"{base_name}_{idx}_{counter}{file_extension}"
                        counter += 1
                    existing_files.add(output_filename)

                    # Save attachment to Dataiku output folder
                    with self.output_folder.get_writer(output_filename) as writer:
                        writer.write(attachment_data)

                    print(f"âœ“ Saved: {output_filename} ({len(attachment_data)} bytes)")
                    attachments_processed += 1

                except Exception as e:
                    print(f"âœ— Failed to process attachment {attachment_name}: {e}")
                    attachments_failed += 1

            msg.close()
            print(f"Completed {msg_name}: {attachments_processed} successful, {attachments_failed} failed")

        except Exception as e:
            print(f"âœ— Failed to process MSG file {msg_name}: {e}")
            attachments_failed += 1

        return attachments_processed, attachments_failed

    def process_batch(self):
        """
        Process all MSG files in the input folder (XLSX only).
        Timestamp values are ignored completely.
        """
        print("Starting batch processing of MSG files (XLSX only, timestamp-safe)...")

        all_files = self.input_folder.list_paths_in_partition()
        msg_files = [f for f in all_files if f.lower().endswith('.msg')]

        if not msg_files:
            print("No MSG files found in input folder")
            return

        print(f"Found {len(msg_files)} MSG files to process")

        total_attachments_processed = 0
        total_attachments_failed = 0

        for msg_file_path in msg_files:
            file_info = {"path": msg_file_path}
            processed, failed = self.process_single_msg(file_info)
            total_attachments_processed += processed
            total_attachments_failed += failed

        # Summary
        print("=" * 50)
        print("PROCESSING SUMMARY")
        print("=" * 50)
        print(f"MSG files processed: {len(msg_files)}")
        print(f"XLSX attachments extracted: {total_attachments_processed}")
        print(f"Attachments failed: {total_attachments_failed}")
        total_attachments = total_attachments_processed + total_attachments_failed
        if total_attachments > 0:
            success_rate = (total_attachments_processed / total_attachments) * 100
            print(f"Success rate: {success_rate:.1f}%")
        print("=" * 50)

def main():
    """
    Main execution for Dataiku
    """
    print("ğŸš€ Starting MSG XLSX Attachment Extraction (timestamp-safe)...")

    try:
        # Initialize Dataiku folders (replace with your folder IDs)
        input_folder = dataiku.Folder("YOUR_INPUT_FOLDER_ID")   # Replace
        output_folder = dataiku.Folder("YOUR_OUTPUT_FOLDER_ID") # Replace

        print(f"ğŸ“ Input folder: {input_folder.get_id()}")
        print(f"ğŸ“ Output folder: {output_folder.get_id()}")

        processor = MSGAttachmentProcessor(input_folder, output_folder)
        processor.process_batch()

        print("âœ… XLSX attachment extraction completed successfully (timestamp-safe)!")

    except Exception as e:
        print(f"âŒ Processing failed: {e}")
        print(traceback.format_exc())
        raise

if __name__ == "__main__":
    main()
