import re
import csv
import sys
import os
from datetime import datetime

def parse_email_chain(text):
    email_pattern = re.compile(
        r"(From:.*?)(?=(?:\nFrom:|\Z))", re.DOTALL | re.IGNORECASE
    )
    emails = re.findall(email_pattern, text)

    parsed_emails = []

    for idx, email in enumerate(emails):
        sender = extract_field(email, r"From: (.*)")
        receiver = extract_field(email, r"To: (.*)")
        cc = extract_field(email, r"Cc: (.*)")
        bcc = extract_field(email, r"Bcc: (.*)")
        subject = extract_field(email, r"Subject: (.*)")
        date_raw = extract_field(email, r"Sent: (.*)")

        date, time = parse_date_time(date_raw)
        body = extract_body(email)

        parsed_emails.append({
            "Email Sequence": idx + 1,
            "Sender": sender,
            "Receiver": receiver,
            "cc": cc,
            "bcc": bcc,
            "subject": subject,
            "email body": body,
            "date": date,
            "time": time
        })

    return parsed_emails

def extract_field(text, pattern):
    match = re.search(pattern, text, re.IGNORECASE)
    return match.group(1).strip() if match else ""

def parse_date_time(date_str):
    if not date_str:
        return "", ""
    try:
        dt = datetime.strptime(date_str.strip(), "%A, %B %d, %Y %I:%M %p")
        return dt.date().isoformat(), dt.time().isoformat()
    except:
        return date_str.strip(), ""

def extract_body(email):
    parts = email.split("\n\n", 1)
    if len(parts) > 1:
        return parts[1].strip()
    return ""

def save_to_csv(parsed_emails, output_file="parsed_emails.csv"):
    if not parsed_emails:
        print("‚ùå No emails found.")
        return

    fieldnames = parsed_emails[0].keys()
    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for row in parsed_emails:
            writer.writerow(row)
    print(f"‚úÖ CSV saved: {output_file}")

def save_summary(parsed_emails, summary_file="summary_output.txt"):
    with open(summary_file, "w", encoding="utf-8") as f:
        for email in parsed_emails:
            f.write(f"\n--- Email #{email['Email Sequence']} ---\n")
            f.write(f"From: {email['Sender']}\n")
            f.write(f"To: {email['Receiver']}\n")
            f.write(f"CC: {email['cc']}\n")
            f.write(f"Subject: {email['subject']}\n")
            f.write(f"Date: {email['date']} {email['time']}\n")
            f.write("Body:\n")
            f.write(email["email body"] + "\n")
    print(f"‚úÖ Summary saved: {summary_file}")

def identify_requester_approver(parsed_emails):
    approver_keywords = [
        "approved", "approve", "looks good", "go ahead", "fine with me",
        "i'm fine", "i agree", "okay", "ok", "sounds good"
    ]
    approver = ""
    requester = ""

    # Find approver (who sent an approval-like message)
    for email in parsed_emails:
        body = email["email body"].lower()
        if any(keyword in body for keyword in approver_keywords):
            approver = email["Sender"]
            break

    # Find requester (earliest sender who is not the approver)
    for email in parsed_emails:
        if email["Sender"] != approver:
            requester = email["Sender"]
            break

    return requester, approver

def save_roles(requester, approver, output_file="requester_approver.txt"):
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(f"Requester: {requester}\n")
        f.write(f"Approver: {approver}\n")
    print(f"‚úÖ Roles saved: {output_file}")

def main():
    if len(sys.argv) != 2:
        print("Usage: python email_parser.py <email_chain.txt>")
        return

    filepath = sys.argv[1]
    if not os.path.exists(filepath):
        print(f"‚ùå File not found: {filepath}")
        return

    # Handle encoding errors using fallback
    with open(filepath, "r", encoding="utf-8", errors="replace") as f:
        email_text = f.read()

    parsed_emails = parse_email_chain(email_text)

    requester, approver = identify_requester_approver(parsed_emails)

    print("\nüîç Identified Roles:")
    print(f"Requester: {requester}")
    print(f"Approver: {approver}")

    save_to_csv(parsed_emails)
    save_summary(parsed_emails)
    save_roles(requester, approver)

if __name__ == "__main__":
    main()
