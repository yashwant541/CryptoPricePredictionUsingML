import re
from datetime import datetime
from typing import List, Dict, Optional

def parse_email_chain(email_text: str) -> List[Dict]:
    """
    Split the email chain into individual emails and extract metadata + body.
    Handles dates in any order and sorts them chronologically.
    """
    # Split emails by common separators (e.g., "---", "Forwarded message")
    email_separator = re.compile(
        r'\n-+\s*Forwarded message\s*-+\n|\n-+\s*Original Message\s*-+\n|\nOn.*wrote:\n|\nFrom:.*\n',
        re.IGNORECASE
    )
    emails = re.split(email_separator, email_text.strip())
    parsed_emails = []

    for email in emails:
        if not email.strip():
            continue

        # Extract sender, date, and body
        sender_match = re.search(r'From:\s*(.*?)\n', email, re.IGNORECASE)
        date_match = re.search(r'Date:\s*(.*?)\n', email, re.IGNORECASE)
        body_match = re.search(r'(?:\n\s*){2,}(.*)', email, re.DOTALL)

        sender = sender_match.group(1).strip() if sender_match else "Unknown"
        date_str = date_match.group(1).strip() if date_match else None
        body = body_match.group(1).strip() if body_match else email.strip()

        # Parse date (supports multiple formats)
        date = None
        if date_str:
            try:
                date = datetime.strptime(date_str, '%a, %d %b %Y %H:%M:%S %z')  # RFC 2822
            except ValueError:
                try:
                    date = datetime.strptime(date_str, '%d %b %Y %H:%M:%S %z')
                except ValueError:
                    try:
                        date = datetime.strptime(date_str, '%m/%d/%Y %I:%M %p')
                    except ValueError:
                        pass  # Keep date as None if parsing fails

        parsed_emails.append({
            'sender': sender,
            'date': date,
            'body': body
        })

    # Sort emails by date (oldest first). If no date, assume order is correct.
    parsed_emails.sort(key=lambda x: x['date'] if x['date'] else datetime.min)
    return parsed_emails

def detect_roles(emails: List[Dict]) -> Dict[str, Optional[str]]:
    """
    Identify requester and approver based on email content and order.
    """
    requester = None
    approver = None

    # Keywords to detect intent (regex)
    request_phrases = [
        r'please approve', r'kindly approve', r'request your approval',
        r'needs? your approval', r'could you approve', r'approval required',
        r'can you approve', r'would you approve'
    ]
    approval_phrases = [
        r'\bapproved\b', r'\bgranted\b', r'\baccepted\b',
        r'\bapproval confirmed\b', r'\bgo ahead\b', r'\bI approve\b',
        r'\bapproved this\b', r'\bapproval granted\b'
    ]

    for email in emails:
        body = email['body'].lower()
        sender = email['sender']

        # Detect requester (first email with a request phrase)
        if not requester:
            for phrase in request_phrases:
                if re.search(phrase, body, re.IGNORECASE):
                    requester = sender
                    break

        # Detect approver (last email with an approval phrase)
        for phrase in approval_phrases:
            if re.search(phrase, body, re.IGNORECASE):
                approver = sender
                break

    # Fallback 1: If no approval found, last replier is approver
    if not approver and len(emails) > 1:
        approver = emails[-1]['sender']

    # Fallback 2: If no requester found, first email sender is requester
    if not requester and emails:
        requester = emails[0]['sender']

    return {
        'requester': requester,
        'approver': approver
    }

def analyze_email_chain(file_path: str) -> Dict[str, Optional[str]]:
    """
    Main function: Read file, parse emails, and detect roles.
    """
    with open(file_path, 'r', encoding='utf-8') as file:
        email_text = file.read()

    emails = parse_email_chain(email_text)
    roles = detect_roles(emails)
    return roles

# Example Usage
if __name__ == "__main__":
    file_path = "email_chain.txt"  # Replace with your file path
    roles = analyze_email_chain(file_path)
    print(f"Requester: {roles['requester']}")
    print(f"Approver: {roles['approver']}")
