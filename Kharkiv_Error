import re
import csv
import sys
import os
from datetime import datetime
from fuzzywuzzy import fuzz
import nltk
from nltk import word_tokenize, pos_tag

# Download required NLTK data once
nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')

# [Previous constant definitions remain the same...]

def clean_email_address(raw_address):
    """Extract clean email addresses from potentially messy strings"""
    if not raw_address:
        return []
    
    # Remove any angle brackets and their contents
    cleaned = re.sub(r'<[^>]+>', '', raw_address)
    # Remove any remaining special characters except comma (for separating addresses)
    cleaned = re.sub(r'[;"\']', '', cleaned)
    # Split by commas and remove whitespace
    addresses = [addr.strip() for addr in cleaned.split(',') if addr.strip()]
    return addresses

def extract_all_participants(parsed_emails):
    """Compile a list of all unique participants in the email chain"""
    participants = set()
    
    for email in parsed_emails:
        # Clean and add sender
        sender = clean_email_address(email["Sender"])
        if sender:
            participants.update(sender)
        
        # Clean and add receivers
        receivers = clean_email_address(email["Receiver"])
        if receivers:
            participants.update(receivers)
        
        # Clean and add CC
        cc = clean_email_address(email["cc"])
        if cc:
            participants.update(cc)
        
        # Clean and add BCC
        bcc = clean_email_address(email["bcc"])
        if bcc:
            participants.update(bcc)
    
    return sorted(participants)

def create_user_role_mapping(parsed_emails, requester, approver):
    """Create a mapping of all participants to their roles"""
    participants = extract_all_participants(parsed_emails)
    role_mapping = []
    
    for participant in participants:
        if participant == requester:
            role = "Requester"
        elif participant == approver:
            role = "Approver"
        else:
            role = "Participant"
        role_mapping.append({"Email": participant, "Role": role})
    
    return role_mapping

def save_user_roles_to_csv(role_mapping, filename="Email_Users.csv"):
    """Save the user role mapping to a CSV file"""
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=["Email", "Role"])
        writer.writeheader()
        writer.writerows(role_mapping)
    print(f"‚úÖ User roles saved: {filename}")

def main(input_file):
    if not os.path.exists(input_file):
        print(f"‚ùå File not found: {input_file}")
        return
    
    with open(input_file, "r", encoding="utf-8") as f:
        email_text = f.read()
    
    parsed_emails = parse_email_chain(email_text)
    if not parsed_emails:
        print("‚ùå No emails could be parsed from the input file.")
        return
    
    save_to_csv(parsed_emails)
    
    requester, approver, scores = identify_requester_approver(parsed_emails)
    save_summary(parsed_emails, scores)
    
    # New functionality: Create and save user roles
    role_mapping = create_user_role_mapping(parsed_emails, requester, approver)
    save_user_roles_to_csv(role_mapping)
    
    print("\nüîç Identified Roles:")
    print(f"Requester: {requester}")
    print(f"Approver: {approver}")
    print(f"\nUser roles saved to Email_Users.csv")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python email_parse.py <input_email_text_file>")
    else:
        main(sys.argv[1])
