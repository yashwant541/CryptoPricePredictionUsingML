import dataiku
import pandas as pd
import zipfile
from io import BytesIO
import tempfile
import os
import sys

# Fixed folder handles using Dataiku folder IDs
input_folder = dataiku.Folder("your_input_folder_id")
output_folder = dataiku.Folder("your_output_folder_id")

def log(message):
    print(f"[LOG] {message}", file=sys.stderr, flush=True)

def process_excel_files_directly():
    """
    Process ZIP file directly from stream without saving to temp file
    """
    try:
        log("üîç Searching for ZIP files in the input folder...")
        zip_files = input_folder.list_paths_in_partition()
        zip_files = [f for f in zip_files if f.lower().endswith(".zip")]
        
        if not zip_files:
            raise Exception("‚ùå No ZIP files found in the input folder.")
        
        zip_path = zip_files[0]
        zip_name = os.path.basename(zip_path)
        log(f"üì¶ Processing: {zip_name}")
        
        # Read ZIP file directly into memory
        with input_folder.get_download_stream(zip_path) as stream:
            zip_content = BytesIO(stream.read())
        
        # Try to open as ZIP file
        try:
            with zipfile.ZipFile(zip_content, 'r') as zf:
                # Get all Excel files from ZIP
                excel_files = [f for f in zf.namelist() if f.lower().endswith(('.xlsx', '.xls'))]
                
                if not excel_files:
                    all_files = zf.namelist()
                    log(f"üìÅ Files in archive: {all_files}")
                    raise Exception("‚ùå No Excel files found in the ZIP archive.")
                
                log(f"üìä Found {len(excel_files)} Excel file(s)")
                
                processed_files = []
                for excel_file in excel_files:
                    try:
                        csv_filename = process_single_excel_directly(zf, excel_file)
                        processed_files.append(csv_filename)
                        log(f"‚úÖ Converted: {excel_file} ‚Üí {csv_filename}")
                    except Exception as e:
                        log(f"‚ö†Ô∏è Failed {excel_file}: {str(e)}")
                        continue
                
                return processed_files
                
        except zipfile.BadZipFile:
            # Check if it might be a single Excel file misnamed as ZIP
            zip_content.seek(0)
            try:
                # Try to read as Excel directly
                df = pd.read_excel(zip_content)
                log("üìä File is actually an Excel file, not a ZIP")
                
                csv_filename = generate_csv_filename(zip_name)
                csv_content = df.to_csv(index=False)
                output_folder.upload_content(csv_filename, csv_content)
                
                log(f"‚úÖ Converted single Excel file: {zip_name} ‚Üí {csv_filename}")
                return [csv_filename]
                
            except Exception as e:
                raise Exception(f"‚ùå File is neither a valid ZIP nor Excel file: {str(e)}")
        
    except Exception as e:
        log(f"üî• ERROR: {str(e)}")
        raise

def process_single_excel_directly(zf, excel_file_path):
    """
    Process single Excel file directly from ZIP stream
    """
    with zf.open(excel_file_path) as excel_file:
        df = pd.read_excel(excel_file)
    
    csv_filename = generate_csv_filename(excel_file_path)
    csv_content = df.to_csv(index=False)
    
    output_folder.upload_content(csv_filename, csv_content)
    return csv_filename

def generate_csv_filename(excel_file_path):
    """
    Generate clean CSV filename from Excel file path
    """
    base_name = os.path.basename(excel_file_path)
    name_without_ext = os.path.splitext(base_name)[0]
    clean_name = "".join(c for c in name_without_ext if c.isalnum() or c in ('-', '_', ' '))
    clean_name = clean_name.replace(' ', '_')
    return f"{clean_name}.csv"

def main():
    log("üöÄ Starting Excel to CSV conversion...")
    try:
        processed_files = process_excel_files_directly()
        log(f"‚úÖ Successfully processed {len(processed_files)} files")
    except Exception as e:
        log(f"üí• Fatal error: {str(e)}")

if __name__ == "__main__":
    main()
