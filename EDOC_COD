import dataiku
import pandas as pd
import zipfile
from io import BytesIO
import tempfile
import os
import sys

# Fixed folder handles using Dataiku folder IDs
input_folder = dataiku.Folder("your_input_folder_id")    # Replace with your input folder ID
output_folder = dataiku.Folder("your_output_folder_id")  # Replace with your output folder ID

def log(message):
    """Logging with flush"""
    print(f"[LOG] {message}", file=sys.stderr, flush=True)

def validate_zip_file(file_path):
    """Check if file is a valid ZIP file"""
    try:
        with zipfile.ZipFile(file_path, 'r') as zf:
            # Test if ZIP file can be read
            return zf.testzip() is None
    except zipfile.BadZipFile:
        return False
    except Exception:
        return False

def process_excel_files_from_zip():
    """
    Process all Excel files from ZIP in input folder and save as CSV in output folder
    """
    tmp_zip_path = None
    
    try:
        log("üîç Searching for ZIP files in the input folder...")
        zip_files = input_folder.list_paths_in_partition()
        zip_files = [f for f in zip_files if f.lower().endswith(".zip")]
        
        if not zip_files:
            raise Exception("‚ùå No ZIP files found in the input folder.")
        
        # Process the first ZIP file found
        zip_path = zip_files[0]
        zip_name = os.path.basename(zip_path)
        log(f"üì¶ Found file: {zip_name}")
        
        # Download file to temp file
        with tempfile.NamedTemporaryFile(suffix=".zip", delete=False) as tmp_zip:
            tmp_zip_path = tmp_zip.name
            with input_folder.get_download_stream(zip_path) as stream:
                # Copy the entire stream to temporary file
                shutil.copyfileobj(stream, tmp_zip)
        
        # Validate that it's actually a ZIP file
        log("üîç Validating ZIP file...")
        if not validate_zip_file(tmp_zip_path):
            # Check file size and content
            file_size = os.path.getsize(tmp_zip_path)
            log(f"üìä File size: {file_size} bytes")
            
            if file_size == 0:
                raise Exception("‚ùå File is empty (0 bytes)")
            
            # Try to read first few bytes to identify file type
            with open(tmp_zip_path, 'rb') as f:
                header = f.read(4)
                log(f"üìÑ File header: {header.hex() if header else 'empty'}")
            
            raise Exception("‚ùå File is not a valid ZIP archive")
        
        log("‚úÖ ZIP file validation passed")
        
        processed_files = []
        
        # Process the ZIP file
        with zipfile.ZipFile(tmp_zip_path, 'r') as zf:
            # Get all Excel files from ZIP
            excel_files = [f for f in zf.namelist() if f.lower().endswith(('.xlsx', '.xls'))]
            
            if not excel_files:
                # List all files in ZIP for debugging
                all_files = zf.namelist()
                log(f"üìÅ Files in archive: {all_files}")
                raise Exception("‚ùå No Excel files found in the ZIP archive.")
            
            log(f"üìä Found {len(excel_files)} Excel file(s) in ZIP")
            
            for excel_file in excel_files:
                try:
                    # Process each Excel file
                    csv_filename = convert_excel_to_csv(zf, excel_file)
                    processed_files.append(csv_filename)
                    log(f"‚úÖ Converted: {excel_file} ‚Üí {csv_filename}")
                    
                except Exception as e:
                    log(f"‚ö†Ô∏è Failed to process {excel_file}: {str(e)}")
                    continue
        
        # Clean up temporary ZIP file
        if tmp_zip_path and os.path.exists(tmp_zip_path):
            os.remove(tmp_zip_path)
        
        log(f"üéâ Processing complete! Successfully converted {len(processed_files)} file(s)")
        for file in processed_files:
            log(f"   üìÑ {file}")
            
        return processed_files
        
    except Exception as e:
        # Clean up temp file if it exists
        if tmp_zip_path and os.path.exists(tmp_zip_path):
            os.remove(tmp_zip_path)
        log(f"üî• ERROR: {str(e)}")
        raise

def convert_excel_to_csv(zf, excel_file_path):
    """
    Convert a single Excel file from ZIP to CSV and upload to output folder
    """
    try:
        # Read Excel file into DataFrame
        with zf.open(excel_file_path) as excel_file:
            df = pd.read_excel(excel_file)
        
        log(f"üìà Read Excel: {excel_file_path} (shape: {df.shape})")
        
        # Generate CSV filename
        csv_filename = generate_csv_filename(excel_file_path)
        
        # Create temporary CSV file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8') as tmp_csv:
            tmp_csv_path = tmp_csv.name
            df.to_csv(tmp_csv, index=False)
        
        # Upload CSV to output folder
        with open(tmp_csv_path, 'rb') as csv_file:
            output_folder.upload_stream(csv_filename, csv_file)
        
        # Clean up temporary CSV file
        os.remove(tmp_csv_path)
        
        return csv_filename
        
    except Exception as e:
        log(f"‚ùå Error converting {excel_file_path}: {str(e)}")
        raise

def generate_csv_filename(excel_file_path):
    """
    Generate clean CSV filename from Excel file path
    """
    # Get base name without extension
    base_name = os.path.basename(excel_file_path)
    name_without_ext = os.path.splitext(base_name)[0]
    
    # Clean the filename (remove special characters)
    clean_name = "".join(c for c in name_without_ext if c.isalnum() or c in ('-', '_', ' '))
    clean_name = clean_name.replace(' ', '_')
    
    csv_filename = f"{clean_name}.csv"
    return csv_filename

def main():
    """
    Main execution function
    """
    log("üöÄ Starting Excel to CSV conversion from ZIP...")
    try:
        processed_files = process_excel_files_from_zip()
        log("‚úÖ All files processed successfully!")
    except Exception as e:
        log(f"üí• Fatal error: {str(e)}")
        # Don't re-raise to see the full error in logs

if __name__ == "__main__":
    main()
