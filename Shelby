import os
import re
import sys
import csv
import math
import shutil
import tempfile
from datetime import datetime
import dataiku
from fuzzywuzzy import fuzz

# -----------------------------
# Outlook .msg Support Setup
# -----------------------------
try:
    import extract_msg
    MSG_SUPPORT = True
    log("‚úÖ extract_msg library loaded successfully")
except ImportError as e:
    MSG_SUPPORT = False
    log(f"‚ö†Ô∏è extract_msg library not installed. .msg file support disabled. Error: {e}")

# ... (keep all your existing configuration and helper functions the same) ...

# -----------------------------
# Enhanced Outlook .msg File Support (FIXED)
# -----------------------------
def parse_msg_file(msg_path):
    """Parse Outlook .msg file and return email data - FIXED VERSION"""
    try:
        log(f"üîç Attempting to parse .msg file: {msg_path}")
        
        # Check if file exists and has content
        if not os.path.exists(msg_path):
            log(f"‚ùå .msg file not found: {msg_path}")
            return None
            
        file_size = os.path.getsize(msg_path)
        if file_size == 0:
            log(f"‚ùå .msg file is empty: {msg_path}")
            return None
            
        log(f"üìÅ .msg file size: {file_size} bytes")
        
        msg = extract_msg.Message(msg_path)
        log("‚úÖ .msg file opened successfully")
        
        # Extract basic email information with safe access
        sender = getattr(msg, 'sender', '') or ""
        recipients = getattr(msg, 'to', '') or ""
        cc = getattr(msg, 'cc', '') or ""
        bcc = getattr(msg, 'bcc', '') or ""
        subject = getattr(msg, 'subject', '') or ""
        body = getattr(msg, 'body', '') or ""
        date_sent = getattr(msg, 'date', None)
        
        log(f"üìß Extracted - Sender: {sender}, Recipients: {recipients}, Subject: {subject[:50]}...")
        
        # Format date
        dt = None
        date_str = ""
        time_str = ""
        
        if date_sent:
            try:
                # Handle different date formats from extract_msg
                if hasattr(date_sent, 'timestamp'):
                    dt = datetime.fromtimestamp(date_sent.timestamp())
                else:
                    # Try to parse string date
                    date_str_raw = str(date_sent)
                    # Common Outlook date formats
                    for fmt in ["%a, %d %b %Y %H:%M:%S %z", "%Y-%m-%d %H:%M:%S", "%d/%m/%Y %H:%M:%S"]:
                        try:
                            dt = datetime.strptime(date_str_raw, fmt)
                            break
                        except ValueError:
                            continue
                    if not dt:
                        dt = datetime.now()  # Fallback to current time
                
                date_str = dt.date().isoformat()
                time_str = dt.time().isoformat()
                log(f"üìÖ Date parsed: {date_str} {time_str}")
            except Exception as date_error:
                log(f"‚ö†Ô∏è Error parsing date: {date_error}")
                dt = datetime.now()
                date_str = dt.date().isoformat()
                time_str = dt.time().isoformat()
        else:
            dt = datetime.now()
            date_str = dt.date().isoformat()
            time_str = dt.time().isoformat()
            log("‚ö†Ô∏è No date found in .msg, using current date")
        
        # Find approval/request statements
        approval_statement, approval_type = find_matching_statement(body, APPROVER_KEYWORDS.keys())
        request_statement, request_type = find_matching_statement(body, REQUESTER_KEYWORDS.keys())
        
        # Extract semantic patterns
        semantic_patterns = extract_semantic_patterns(body)
        
        # Log what we found
        if approval_statement:
            log(f"‚úÖ Found approval statement: {approval_statement[:50]}...")
        if request_statement:
            log(f"‚úÖ Found request statement: {request_statement[:50]}...")
        
        msg.close()
        
        email_data = {
            "Email Sequence": 1,
            "Sender": sender,
            "Receiver": recipients,
            "cc": cc,
            "bcc": bcc,
            "subject": subject,
            "email body": body,
            "approval statement": approval_statement or "",
            "approval match type": approval_type or "",
            "request statement": request_statement or "",
            "request match type": request_type or "",
            "semantic_patterns": str(semantic_patterns),
            "datetime": dt,
            "date": date_str,
            "time": time_str
        }
        
        log(f"‚úÖ Successfully parsed .msg file with {len(body)} characters in body")
        return email_data
        
    except Exception as e:
        log(f"‚ùå Error parsing .msg file {msg_path}: {str(e)}")
        import traceback
        log(f"‚ùå Traceback: {traceback.format_exc()}")
        return None

def parse_msg_chain(msg_file_path):
    """Parse a single .msg file as an email chain (single email) - FIXED"""
    log(f"üîÑ Starting .msg chain parsing for: {msg_file_path}")
    email_data = parse_msg_file(msg_file_path)
    if email_data:
        log(f"‚úÖ .msg parsing successful, returning 1 email")
        return [email_data]
    else:
        log(f"‚ùå .msg parsing failed, returning empty list")
        return []

# -----------------------------
# Enhanced Main Execution with DEBUGGING .msg Support
# -----------------------------
def main():
    INPUT_FOLDER_CODE = "YOUR_INPUT_FOLDER_ID"   # Replace with your Dataiku input folder code
    OUTPUT_FOLDER_CODE = "YOUR_OUTPUT_FOLDER_ID" # Replace with your Dataiku output folder code

    input_folder = dataiku.Folder(INPUT_FOLDER_CODE)
    output_folder = dataiku.Folder(OUTPUT_FOLDER_CODE)

    # List all supported files (.txt and .msg if available)
    supported_files = []
    all_files = input_folder.list_paths_in_partition()
    
    log(f"üìÅ Found {len(all_files)} files in input folder")
    
    for file_path in all_files:
        file_lower = file_path.lower()
        log(f"üîç Checking file: {file_path} (extension: {os.path.splitext(file_path)[1]})")
        
        if file_lower.endswith(".txt"):
            supported_files.append(file_path)
            log(f"‚úÖ Added .txt file: {file_path}")
        elif file_lower.endswith(".msg"):
            if MSG_SUPPORT:
                supported_files.append(file_path)
                log(f"‚úÖ Added .msg file: {file_path}")
            else:
                log(f"‚ö†Ô∏è .msg file {file_path} found but extract_msg library not installed. Skipping.")
    
    if not supported_files:
        log("‚ùå No supported email files (.txt or .msg) found in input folder.")
        return

    log(f"üîÑ Starting processing of {len(supported_files)} supported files")
    
    for email_file in supported_files:
        log(f"üìÑ Processing {email_file}...")
        
        parsed_emails = []
        file_extension = os.path.splitext(email_file)[1].lower()
        
        try:
            if file_extension == ".txt":
                # Process .txt file
                log(f"üìù Processing as .txt file")
                with tempfile.NamedTemporaryFile(suffix=".txt", delete=False, mode='wb') as tmp_file:
                    tmp_path = tmp_file.name
                    log(f"üíæ Downloading to temp file: {tmp_path}")
                    with input_folder.get_download_stream(email_file) as stream:
                        shutil.copyfileobj(stream, tmp_file)

                # Read file content
                with open(tmp_path, "r", encoding="utf-8", errors='ignore') as f:
                    email_text = f.read()
                log(f"üìñ Read {len(email_text)} characters from .txt file")

                parsed_emails = parse_email_chain(email_text)
                log(f"üìß Parsed {len(parsed_emails)} emails from .txt file")
                os.remove(tmp_path)
                
            elif file_extension == ".msg" and MSG_SUPPORT:
                # Process .msg file
                log(f"üìß Processing as .msg file")
                with tempfile.NamedTemporaryFile(suffix=".msg", delete=False, mode='wb') as tmp_file:
                    tmp_path = tmp_file.name
                    log(f"üíæ Downloading .msg to temp file: {tmp_path}")
                    with input_folder.get_download_stream(email_file) as stream:
                        shutil.copyfileobj(stream, tmp_file)
                    log(f"üíæ .msg file saved to {tmp_path}, size: {os.path.getsize(tmp_path)} bytes")

                parsed_emails = parse_msg_chain(tmp_path)
                log(f"üìß Parsed {len(parsed_emails)} emails from .msg file")
                
                # Clean up temp file
                if os.path.exists(tmp_path):
                    os.remove(tmp_path)
                    log(f"üßπ Cleaned up temp file: {tmp_path}")

        except Exception as e:
            log(f"‚ùå Error processing file {email_file}: {str(e)}")
            import traceback
            log(f"‚ùå Traceback: {traceback.format_exc()}")
            continue

        if not parsed_emails:
            log(f"‚ö†Ô∏è No emails parsed in {email_file}. Skipping.")
            continue

        log(f"‚úÖ Successfully parsed {len(parsed_emails)} emails from {email_file}")

        # Enhanced identification with all new features
        try:
            maker, checker, scores, candidates, confidence, confidence_factors, context, method_used, restrictions = identify_maker_checker_with_restrictions(parsed_emails)
            
            base_name = os.path.splitext(os.path.basename(email_file))[0]

            # Save enhanced outputs
            log(f"üíæ Saving outputs for {base_name}")
            save_enhanced_csv(parsed_emails, output_folder, f"parsed_emails_{base_name}.csv")
            save_participant_analysis_csv(parsed_emails, output_folder, f"participant_analysis_{base_name}.csv")
            save_enhanced_summary(
                parsed_emails, scores, output_folder, f"enhanced_summary_{base_name}.txt",
                maker, checker, confidence, confidence_factors, context, method_used, restrictions
            )
            save_enhanced_user_roles(parsed_emails, maker, checker, output_folder, f"users_{base_name}.csv")

            log(f"‚úÖ Finished processing {email_file}")
            log(f"   üìã Results - Maker: {maker}, Checker: {checker}, Confidence: {confidence}")
            
        except Exception as e:
            log(f"‚ùå Error during analysis of {email_file}: {str(e)}")
            import traceback
            log(f"‚ùå Traceback: {traceback.format_exc()}")

    log("üéâ All files processed!")

if __name__ == "__main__":
    main()
