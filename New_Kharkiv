import re
import csv
import sys
import os
import math
from datetime import datetime
from fuzzywuzzy import fuzz
import nltk
from nltk import word_tokenize, pos_tag

# Download required NLTK data once
nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')

# Weighted keyword lists
APPROVER_KEYWORDS = {
    "approved": 100, "granted": 95, "confirmed": 90, "accepted": 90,
    "authorized": 95, "approve": 80, "confirm": 80, "accept": 80,
    "approval": 50, "clearance": 70, "endorsed": 75, "signed off": 85,
    "cleared": 80, "validated": 85, "ratified": 90, "sanctioned": 90
}

REQUESTER_KEYWORDS = {
    "request": 100, "require": 95, "seek approval": 90, "need approval": 90,
    "asking": 80, "petition": 75, "approval": 30, "pending": 60,
    "remind": 70, "follow up": 65, "submitted": 85, "application": 80,
    "awaiting": 75, "petition": 70, "seeking": 85
}

PRONOUN_PATTERNS = [
    (r"\byou\b.*\bapprove\b", "approver", 50),
    (r"\byour\b.*\bapproval\b", "approver", 40),
    (r"\bplease\b.*\bapprove\b", "approver", 60),
    (r"\bi\b.*\brequest\b", "requester", 55),
    (r"\bwe\b.*\brequest\b", "requester", 50),
    (r"\bplease\b.*\breview\b", "approver", 40),
    (r"\bkindly\b.*\bapprove\b", "approver", 70)
]

# Temporal weighting functions
def sigmoid(x, steepness=10, midpoint=0.5):
    """Smooth S-curve transition between requester and approver weights"""
    return 1 / (1 + math.exp(-steepness * (x - midpoint)))

def logarithmic_weight(position, total_emails):
    """
    More sensitive to early positions in thread
    Returns weight between 0 and 1
    """
    if total_emails <= 1:
        return 0.5
    normalized_pos = position / (total_emails - 1)
    return 1 - math.log(1 + (1 - normalized_pos) * 9, 10)  # log10(1) to log10(10)

def hybrid_temporal_weight(position, total_emails, sigmoid_ratio=0.7):
    """
    Combine both sigmoid and logarithmic weights
    sigmoid_ratio: 0-1, blend between approaches
    """
    if total_emails <= 1:
        return (0.5, 0.5)
    
    normalized_pos = position / (total_emails - 1)
    req_sig, app_sig = (1 - sigmoid(normalized_pos)), sigmoid(normalized_pos)
    log_weight = logarithmic_weight(position, total_emails)
    
    # Blend them
    requester_weight = sigmoid_ratio * (1 - log_weight) + (1 - sigmoid_ratio) * req_sig
    approver_weight = sigmoid_ratio * log_weight + (1 - sigmoid_ratio) * app_sig
    
    # Normalize
    total = requester_weight + approver_weight
    return (requester_weight/total, approver_weight/total)

def time_decay_weight(email_datetime, thread_start, thread_end, half_life_hours=24):
    """
    Weight based on absolute time differences
    half_life_hours: time for weight to reduce by half
    """
    total_span = (thread_end - thread_start).total_seconds()
    if total_span <= 0:
        return (0.5, 0.5)
    
    elapsed = (email_datetime - thread_start).total_seconds()
    decay_factor = 0.5 ** (elapsed / (half_life_hours * 3600))
    
    return (decay_factor, 1 - decay_factor)

# Rest of the existing functions remain the same until calculate_role_scores

def calculate_role_scores(parsed_emails):
    role_scores = {}
    total_emails = len(parsed_emails)
    
    # Get thread time bounds
    valid_emails = [e for e in parsed_emails if e["datetime"]]
    if valid_emails:
        thread_start = min(e["datetime"] for e in valid_emails)
        thread_end = max(e["datetime"] for e in valid_emails)
    else:
        thread_start = thread_end = None
    
    # Get first sender based on datetime
    first_email = min(parsed_emails, key=lambda x: x["datetime"] if x["datetime"] else datetime.max)
    first_sender = clean_participant_name(first_email["Sender"])

    for i, email in enumerate(parsed_emails):
        sender = clean_participant_name(email["Sender"])
        body = email["email body"].lower()
        subject = email["subject"].lower()
        
        if not sender:
            continue
            
        if sender not in role_scores:
            role_scores[sender] = {"approver": 0, "requester": 0, "details": []}
        
        # Calculate temporal weights using hybrid approach
        pos_weight_req, pos_weight_app = hybrid_temporal_weight(i, total_emails)
        
        # Calculate time decay weights if we have datetimes
        if email["datetime"] and thread_start and thread_end:
            time_weight_req, time_weight_app = time_decay_weight(
                email["datetime"], thread_start, thread_end
            )
        else:
            time_weight_req, time_weight_app = 0.5, 0.5
        
        # Combine weights (50% position, 50% time decay)
        combined_req = 0.5 * pos_weight_req + 0.5 * time_weight_req
        combined_app = 0.5 * pos_weight_app + 0.5 * time_weight_app
        
        # Apply to scores (20% of total score)
        role_scores[sender]["requester"] += 20 * combined_req
        role_scores[sender]["approver"] += 20 * combined_app
        role_scores[sender]["details"].append(
            f"+{20*combined_req:.1f} (temporal requester weight)")
        role_scores[sender]["details"].append(
            f"+{20*combined_app:.1f} (temporal approver weight)")
        
        # ULTRA WINNER BONUS - First explicit approval
        if "approved" in body and sender != first_sender:
            # Check if this is the first approval in the entire chain
            if not any(e["approval statement"] for e in parsed_emails[:i]):
                role_scores[sender]["approver"] += 200
                role_scores[sender]["details"].append(
                    "+200 (ULTRA WINNER - first explicit approval)")
            else:
                role_scores[sender]["approver"] += 100
                role_scores[sender]["details"].append(
                    "+100 (explicit approval)")
        
        # HARD RULE: First sender can NEVER be approver
        if sender == first_sender:
            role_scores[sender]["approver"] = 0
            role_scores[sender]["details"].append(
                "0 (FIRST SENDER CANNOT BE APPROVER - hard rule)")
            # Give extra requester points for being initiator
            role_scores[sender]["requester"] += 50
            role_scores[sender]["details"].append(
                "+50 (first email initiator bonus)")
        
        # Keyword Scoring (50%)
        # Approval scoring (only for non-first senders)
        if sender != first_sender:
            for kw, weight in APPROVER_KEYWORDS.items():
                if kw in body:
                    adjusted_weight = weight
                    if kw == "approval" and i < total_emails/2:
                        adjusted_weight *= 0.6
                    role_scores[sender]["approver"] += adjusted_weight
                    role_scores[sender]["details"].append(
                        f"+{adjusted_weight} (approver keyword: '{kw}')")
        
        # Request scoring
        for kw, weight in REQUESTER_KEYWORDS.items():
            if kw in body:
                adjusted_weight = weight
                if kw == "approval" and ("request" in body or "need" in body):
                    adjusted_weight *= 1.5
                role_scores[sender]["requester"] += adjusted_weight
                role_scores[sender]["details"].append(
                    f"+{adjusted_weight} (requester keyword: '{kw}')")
        
        # Pronoun patterns
        for pattern, role, weight in PRONOUN_PATTERNS:
            if re.search(pattern, body, re.IGNORECASE):
                role_scores[sender][role] += weight
                role_scores[sender]["details"].append(
                    f"+{weight} (pronoun pattern: '{pattern}')")
        
        # Clear approval statements
        if re.search(r"\b(i|we) (have |'ve )?(approved|granted)", body):
            if sender != first_sender:
                role_scores[sender]["approver"] += 100
                role_scores[sender]["details"].append(
                    "+100 (explicit approval statement)")
    
    return role_scores, first_sender

# Rest of the existing functions remain unchanged...

def main(input_file):
    if not os.path.exists(input_file):
        print(f"❌ File not found: {input_file}")
        return
    
    with open(input_file, "r", encoding="utf-8") as f:
        email_text = f.read()
    
    parsed_emails = parse_email_chain(email_text)
    if not parsed_emails:
        print("❌ No emails could be parsed from the input file.")
        return
    
    save_to_csv(parsed_emails)
    
    requester, approver, scores, first_sender = identify_requester_approver(parsed_emails)
    save_summary(parsed_emails, scores)
    
    # Create and save user roles
    role_mapping = create_user_role_mapping(parsed_emails, requester, approver)
    save_user_roles_to_csv(role_mapping)
    
    print("\n🔍 Identified Roles:")
    print(f"First Sender (can't be approver): {first_sender}")
    print(f"Requester: {requester}")
    print(f"Approver: {approver}")
    print(f"\nUser roles saved to Email_Users.csv")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python email_parse.py <input_email_text_file>")
    else:
        main(sys.argv[1])
