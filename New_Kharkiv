import pandas as pd

def merge_and_resolve_categorisation(client_income_df, sabre_product_df, murex_product_df):
    # Create a helper function to merge on multiple columns with fallback for null values
    def merge_with_fallback(df1, df2, key1_a, key1_b, key2_a, key2_b):
        # First merge on primary keys
        merged_primary = pd.merge(df1, df2, left_on=key1_a, right_on=key2_a, how='left')
        # Merge on secondary keys where primary key merge did not succeed
        merged_secondary = pd.merge(df1, df2, left_on=key1_b, right_on=key2_b, how='left')
        # Combine results giving precedence to non-null primary key merges
        merged = merged_primary.combine_first(merged_secondary)
        return merged

    # Merge client_income_df with sabre_product_df using Trade_Id and External_Trade_Id with fallbacks
    merged_AB = merge_with_fallback(client_income_df, sabre_product_df, 'Trade_Id', 'External_Trade_Id', 'trade id', 'External_Trade_ID')

    # Merge the resulting DataFrame with murex_product_df using Trade_Id and External_Trade_Id with fallbacks
    merged_ABC = merge_with_fallback(merged_AB, murex_product_df, 'Trade_Id', 'External_Trade_Id', 'trade id', 'External_Trade_ID')

    # Resolve the Product Categorisation column from murex_product_df (or sabre_product_df)
    merged_ABC['Product Categorisation'] = merged_ABC.apply(lambda row: row['Product Categorisation_y'] if pd.notnull(row['Product Categorisation_y']) else row['Product Categorisation_x'], axis=1)

    # Drop the intermediate Product Categorisation columns
    merged_ABC.drop(columns=['Product Categorisation_x', 'Product Categorisation_y'], inplace=True)

    # Ensure row count of client_income_df is intact
    merged_ABC = merged_ABC.combine_first(client_income_df)

    return merged_ABC
