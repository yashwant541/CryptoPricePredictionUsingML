import dataiku
from dataiku import pandasutils as pdu
import pandas as pd
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import pyminizip
import os

# Load the dataset with email information
dataset = dataiku.Dataset("your_dataset_name")  # Replace with your dataset name in Dataiku
email_data = dataset.get_dataframe()

# SMTP configuration (update as per your settings)
SMTP_SERVER = "smtp.example.com"  # Replace with your SMTP server
SMTP_PORT = 587  # Common SMTP port for TLS
SMTP_USERNAME = "your_email@example.com"
SMTP_PASSWORD = "your_email_password"

# Function to send an email with a password-protected zip attachment
def send_email(to_address, subject, body, attachment_path, zip_password=None):
    try:
        # Initialize the email message
        msg = MIMEMultipart()
        msg['From'] = SMTP_USERNAME
        msg['To'] = to_address
        msg['Subject'] = subject

        # Attach the email body
        msg.attach(MIMEText(body, 'plain'))

        # Zip the file if a password is provided
        if zip_password and attachment_path:
            zip_filename = "protected_attachment.zip"
            pyminizip.compress(attachment_path, None, zip_filename, zip_password, 5)
            attachment_path = zip_filename  # Update the attachment path to the zip file

        # Attach the file
        if attachment_path:
            with open(attachment_path, "rb") as attachment:
                part = MIMEBase("application", "octet-stream")
                part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header("Content-Disposition", f"attachment; filename= {os.path.basename(attachment_path)}")
            msg.attach(part)

        # Connect to the SMTP server and send the email
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        server.sendmail(SMTP_USERNAME, to_address, msg.as_string())
        print(f"Email sent to {to_address}")
        
    except Exception as e:
        print(f"Failed to send email to {to_address}: {e}")
        
    finally:
        server.quit()
        # Clean up the zip file if created
        if zip_password and os.path.exists(zip_filename):
            os.remove(zip_filename)

# Iterate over each row in the dataset and send an email
for index, row in email_data.iterrows():
    to_address = row['Email']
    subject = row['Subject']
    body = row['Body']
    attachment_path = row.get('Attachment File Path')
    zip_password = row.get('Password')  # Optional password for the zip file

    send_email(to_address, subject, body, attachment_path, zip_password)
