from docx import Document
from docx.shared import RGBColor
from docx.enum.section import WD_SECTION
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
import pandas as pd
from io import BytesIO
from PIL import Image


# File Paths
input_file = 'input_data.csv'  # Change this to your file path
template_file = 'template.docx'  # Path to the Word template
output_file = 'dynamic_report.docx'  # Output Word file
image_file = 'front_page_image.png'  # Path to the PNG image for the front page

# Read the input data (CSV or Excel)
if input_file.endswith('.csv'):
    df = pd.read_csv(input_file)
elif input_file.endswith('.xlsx'):
    df = pd.read_excel(input_file)

# Convert Date column if exists and sort by latest date
date_column = None
for col in df.columns:
    if 'date' in col.lower():  # Find any column with "date" in its name
        date_column = col
        df[date_column] = pd.to_datetime(df[date_column], errors='coerce')
        df = df.sort_values(by=date_column, ascending=False).reset_index(drop=True)
        break

# Read the template Word document
doc = Document(template_file)

# Create a new document for output
output_doc = Document()

# Function to set the page size to landscape and match the PNG image size
def set_landscape_page_size(doc, image_path):
    # Open the image to get its dimensions
    with Image.open(image_path) as img:
        width, height = img.size  # Get image dimensions

    # Set the page size based on image dimensions (landscape orientation)
    section = doc.sections[0]
    section.orientation = WD_SECTION.LANDSCAPE
    section.page_width = width * 1.0  # 1.0 is the factor to convert from pixels to twips
    section.page_height = height * 1.0

    # Create a footer for page numbering
    footer = section.footer
    paragraph = footer.paragraphs[0] if footer.paragraphs else footer.add_paragraph()
    paragraph.text = "Report"

# Set the landscape page size using the front page image
set_landscape_page_size(output_doc, image_file)

# Add the front page image
section = output_doc.sections[0]
footer = section.footer
paragraph = footer.paragraphs[0] if footer.paragraphs else footer.add_paragraph()
run = paragraph.add_run()
run.add_picture(image_file)

# Start adding the second page's content (for the report)
section_style = {
    'font_name': 'Times New Roman',
    'font_size': 12,
    'font_color': RGBColor(0x38, 0xD2, 0x00)  # Green color for text
}

# Loop through the rows in the dataframe and add data dynamically
for idx, row in df.iterrows():
    # Add the section title (using the first column as the title)
    title_text = row[df.columns[0]] if len(df.columns) > 0 else "No Title"
    title_paragraph = output_doc.add_paragraph(f"Record {idx + 1}: {title_text}", style="Heading 2")
    
    # Loop through the columns of the current row and add to the document
    for col in df.columns:
        if pd.notna(row[col]):
            # Format date if it's a date column
            if col == date_column:
                formatted_date = row[col].strftime('%d-%m-%Y') if pd.notnull(row[col]) else 'N/A'
                output_doc.add_paragraph(f"{col}: {formatted_date}", style="Normal")
            else:
                output_doc.add_paragraph(f"{col}: {row[col]}", style="Normal")

    # Add a page break if the content exceeds the current page, to keep the layout clean
    if idx % 10 == 0:  # Adjust this number based on how much content fits on one page
        output_doc.add_page_break()

# Add the last page (if required)
# (Assuming the last page is simple, just copy it from the template)
for i, element in enumerate(doc.element.body):
    if i == len(doc.element.body) - 1:
        output_doc.element.body.append(element)

# Save the document
output_doc.save(output_file)

print(f"Dynamic Word report created: {output_file}")
