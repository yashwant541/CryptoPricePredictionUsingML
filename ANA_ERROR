# ============================================================
#      NOMINEE NAME VALIDATION (DATAIKU VERSION)
#   WITH RELATIONSHIP NO & ACCOUNT NO RETAINED
# ============================================================

import dataiku
import pandas as pd
import re

# ------------------------------------------------------------
# READ DATAIKU INPUT DATASET
# ------------------------------------------------------------
input_ds = dataiku.Dataset("input_dataset")     # <-- change dataset name
df = input_ds.get_dataframe()

# Ensure Relationship No & Account No exist
REL_COL = "relationship_no"
ACC_COL = "account_no"

# ------------------------------------------------------------
# VALIDATION HELPERS
# ------------------------------------------------------------

def is_one_word_name(name):
    if not isinstance(name, str):
        return False
    cleaned = name.strip()
    tokens = cleaned.split()
    if len(tokens) == 1:
        token = tokens[0]
        if len(token) >= 2 and re.search(r"[A-Za-z]", token):
            return True
    return False


RANDOM_WORDS = {
    "nomination", "nominee", "nominatn", "nominated",
    "qwerty", "asdf", "zxcv", "xyz", "abc", "abcd", "lmnop"
}

GIBBERISH_PATTERN = re.compile(r"^[A-Za-z]{5,}$")
VOWEL_RATIO_THRESHOLD = 0.10

def is_random_or_nonsense(name):
    if not isinstance(name, str):
        return False
    
    cleaned = name.strip().lower()

    if cleaned in RANDOM_WORDS:
        return True

    if len(set(cleaned)) == 1 and len(cleaned) >= 3:
        return True

    if GIBBERISH_PATTERN.match(cleaned):
        vowels = sum(ch in "aeiou" for ch in cleaned)
        if vowels / (len(cleaned) + 1e-6) < VOWEL_RATIO_THRESHOLD:
            return True

    return False


# ------------------------------------------------------------
# MAIN VALIDATION FUNCTION
# ------------------------------------------------------------

def validate_nominee_name(name):
    issues = []

    if not isinstance(name, str) or not name.strip():
        issues.append("Missing or empty name")
        return issues

    cleaned = name.strip()

    PLACEHOLDERS = ["na", "n/a", "-", "--", "none", "unknown", "nil", "self"]
    if cleaned.lower() in PLACEHOLDERS:
        issues.append("Placeholder / invalid word")

    if re.search(r"\d", cleaned):
        issues.append("Contains digits")

    if re.search(r"[^\w\s.'-]", cleaned):
        issues.append("Contains special characters")

    if re.search(r"@\w+\.\w+", cleaned):
        issues.append("Contains email-like pattern")

    if re.search(r"\b\d{8,}\b", cleaned):
        issues.append("Contains phone number")

    REL_WORDS = ["mother", "father", "son", "daughter", "wife", "husband"]
    if cleaned.lower() in REL_WORDS:
        issues.append("Relationship word instead of name")

    if re.fullmatch(r"[A-Za-z]\.?$", cleaned):
        issues.append("Initials only")

    if is_one_word_name(cleaned):
        issues.append("One-word name (possibly incomplete)")

    if is_random_or_nonsense(cleaned):
        issues.append("Random / nonsensical name")

    if len(cleaned) < 2:
        issues.append("Name too short")

    if len(cleaned) > 70:
        issues.append("Name too long")

    return issues


# ------------------------------------------------------------
# APPLY VALIDATION TO DATAFRAME
# ------------------------------------------------------------
column = "name"

df["nominee_issues"] = df[column].apply(validate_nominee_name)
df["issue_count"] = df["nominee_issues"].apply(len)

# Boolean flags for easier filtering
df["is_missing"]           = df["nominee_issues"].apply(lambda x: "Missing or empty name" in x)
df["has_digits"]           = df["nominee_issues"].apply(lambda x: "Contains digits" in x)
df["has_special_chars"]    = df["nominee_issues"].apply(lambda x: "Contains special characters" in x)
df["is_one_word"]          = df["nominee_issues"].apply(lambda x: "One-word name (possibly incomplete)" in x)
df["is_nonsense"]          = df["nominee_issues"].apply(lambda x: "Random or nonsensical name" in x)
df["is_initial_only"]      = df["nominee_issues"].apply(lambda x: "Initials only" in x)
df["is_placeholder"]       = df["nominee_issues"].apply(lambda x: "Placeholder / invalid word" in x)
df["is_relationship_word"] = df["nominee_issues"].apply(lambda x: "Relationship word instead of name" in x)
df["has_phone"]            = df["nominee_issues"].apply(lambda x: "Contains phone number" in x)
df["has_email"]            = df["nominee_issues"].apply(lambda x: "Contains email-like pattern" in x)

# Relationship No & Account No automatically preserved in df
# They will appear next to issues in the output


# ------------------------------------------------------------
# WRITE OUTPUT DATASET TO DATAIKU
# ------------------------------------------------------------
output_ds = dataiku.Dataset("output_dataset")   # <-- change dataset name
output_ds.write_with_schema(df)
