# ============================================================
#      NOMINEE NAME VALIDATION (DATAIKU VERSION)
#      FULL VERSION WITH:
#        - FUZZY NAME SIMILARITY (SEPARATE COLUMN)
#        - IMPROVED NOM/NOMINATION DETECTION
#        - SINGLE ISSUE LABEL FOR RELATIONSHIP WORDS
# ============================================================

import dataiku
import pandas as pd
import re
from rapidfuzz import fuzz

# ------------------------------------------------------------
# READ INPUT DATASET
# ------------------------------------------------------------
input_ds = dataiku.Dataset("input_dataset")   # <-- change to your input dataset
df = input_ds.get_dataframe()

# Required columns
REL_COL = "relationship_no"
ACC_COL = "account_no"
NOM_COL = "name"                   # nominee name
ACC_HOLDER_COL = "account_holder_name"  # account holder name (for similarity check)

# ------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------

def is_one_word_name(name):
    if not isinstance(name, str):
        return False
    parts = name.strip().split()
    return len(parts) == 1 and len(parts[0]) >= 2

RANDOM_WORDS = {"nomination","nominee","nominatn","nominated","qwerty","asdf","zxcv","xyz","abc","abcd","lmnop"}
GIBBERISH_PATTERN = re.compile(r"^[A-Za-z]{5,}$")
VOWEL_RATIO_THRESHOLD = 0.10

def is_random_or_nonsense(name):
    if not isinstance(name, str):
        return False
    clean = name.strip().lower()
    if clean in RANDOM_WORDS:
        return True
    if len(set(clean)) == 1 and len(clean) >= 3:
        return True
    if GIBBERISH_PATTERN.match(clean):
        vowels = sum(ch in "aeiou" for ch in clean)
        if vowels / (len(clean)+1e-6) < VOWEL_RATIO_THRESHOLD:
            return True
    return False

RELATIONSHIP_WORDS = [
    "mother","mom","mummy","mamma","ma",
    "father","dad","daddy","papa",
    "son","daughter","child","children",
    "wife","husband","spouse",
    "brother","sister","sibling",
    "uncle","aunty","aunt","nephew","niece",
    "grandmother","grandfather","grandma","grandpa",
    "guardian","caretaker"
]

KEYBOARD_RANDOM = ["qwerty","asdf","zxcv","xyz"]

PLACEHOLDERS = ["na","n/a","none","null","-","--","nominee","self","unknown"]

# ------------------------------------------------------------
# FUZZY SIMILARITY CHECK FUNCTION (NEW COLUMN)
# ------------------------------------------------------------
def fuzzy_similarity_check(nominee_name, account_holder_name):
    results = []
    if not isinstance(nominee_name, str) or not isinstance(account_holder_name, str):
        return results

    nominee_clean = nominee_name.lower().strip()
    account_clean = account_holder_name.lower().strip()
    account_tokens = account_clean.split()

    # 1️⃣ Substring token check
    for token in account_tokens:
        if token in nominee_clean:
            results.append(f"Account holder token '{token}' found in nominee name")
            break

    # 2️⃣ Fuzzy full similarity
    ratio = fuzz.partial_ratio(account_clean, nominee_clean)
    if ratio >= 80:
        results.append(f"High similarity to account holder name ({ratio}%)")

    # 3️⃣ Token-wise fuzzy similarity
    for token in account_tokens:
        score = fuzz.partial_ratio(token, nominee_clean)
        if score >= 85:
            results.append(f"Token-level fuzzy similarity ({token}: {score}%)")
            break

    return results

# ------------------------------------------------------------
# MAIN NOMINEE VALIDATION FUNCTION
# ------------------------------------------------------------
def validate_nominee_name(nominee_name):
    issues = []

    if not isinstance(nominee_name, str) or not nominee_name.strip():
        issues.append("Missing or empty name")
        return issues

    clean_name = nominee_name.strip()
    lower_name = clean_name.lower()

    # Placeholder values
    if lower_name in PLACEHOLDERS:
        issues.append("Placeholder / invalid word")

    # One-word names
    if is_one_word_name(clean_name):
        issues.append("One-word name (possibly incomplete)")

    # Digits
    if re.search(r"\d", clean_name):
        issues.append("Contains digits")

    # Special characters (excluding . ' -)
    if re.search(r"[^\w\s.'-]", clean_name):
        issues.append("Contains special characters")

    # Initial-only
    if re.fullmatch(r"[A-Za-z]\.?", clean_name):
        issues.append("Initials only")

    # Random / nonsense
    if is_random_or_nonsense(clean_name):
        issues.append("Random or nonsensical name")

    # Keyboard/random words
    for kb in KEYBOARD_RANDOM:
        if kb in lower_name:
            issues.append(f"Random keyboard-like text found ({kb})")
            break

    # Improved NOM / NOMINATION detection
    if re.search(r"(?:^|\s|[.,;:!?])nom(?:$|\s|[.,;:!?])", lower_name, re.IGNORECASE) \
       or re.search(r"(?:^|\s|[.,;:!?])nomination(?:$|\s|[.,;:!?])", lower_name, re.IGNORECASE):
        issues.append("Contains 'NOM' or 'NOMINATION' pattern (as separate word or with boundary)")

    # Relationship words – always flag as single issue label
    relationship_found = [rel for rel in RELATIONSHIP_WORDS if re.search(rf"\b{rel}\b", lower_name)]
    if relationship_found:
        issues.append("Relationship word used instead of name")

    # Length checks
    if len(clean_name) < 2:
        issues.append("Name too short")
    if len(clean_name) > 70:
        issues.append("Name too long")

    return issues

# ------------------------------------------------------------
# APPLY VALIDATION
# ------------------------------------------------------------
# Nominee issues
df["nominee_issues"] = df[NOM_COL].apply(validate_nominee_name)
df["issue_count"] = df["nominee_issues"].apply(len)

# Fuzzy similarity issues as separate column
df["fuzzy_similarity_issues"] = df.apply(lambda x: fuzzy_similarity_check(x[NOM_COL], x[ACC_HOLDER_COL]), axis=1)

# Boolean flags for nominee_issues
df["has_nom_pattern"]       = df["nominee_issues"].apply(lambda x: any("NOM" in i.upper() for i in x))
df["has_relationship_word"] = df["nominee_issues"].apply(lambda x: any("Relationship word" in i for i in x))
df["is_nonsense"]           = df["nominee_issues"].apply(lambda x: any("Random or nonsensical" in i for i in x))
df["is_one_word"]           = df["nominee_issues"].apply(lambda x: any("One-word name" in i for i in x))
df["has_digits"]            = df["nominee_issues"].apply(lambda x: any("Contains digits" in i for i in x))
df["has_special_chars"]     = df["nominee_issues"].apply(lambda x: any("special characters" in i for i in x))
df["is_initial_only"]       = df["nominee_issues"].apply(lambda x: any("Initials only" in i for i in x))
df["is_placeholder"]        = df["nominee_issues"].apply(lambda x: any("Placeholder" in i for i in x))
df["is_missing"]            = df["nominee_issues"].apply(lambda x: any("Missing" in i for i in x))

# ------------------------------------------------------------
# WRITE OUTPUT DATASET
# ------------------------------------------------------------
output_ds = dataiku.Dataset("output_dataset")  # <-- change dataset name
output_ds.write_with_schema(df)
