import pandas as pd
import os
import tempfile
import numpy as np
from datetime import datetime

# Try importing Dataiku (skip if running locally)
try:
    import dataiku
except ImportError:
    dataiku = None

# =====================================================
# ‚öôÔ∏è CONFIGURATION
# =====================================================
USE_DATAIKU = True  # Toggle: True = Dataiku, False = Local

# --- Local paths (used if USE_DATAIKU = False)
local_input_folder = r"C:\Users\YourName\Desktop\Input"
local_output_folder = r"C:\Users\YourName\Desktop\Output"

# --- Dataiku folder IDs
DATAIKU_INPUT_FOLDER_ID = "input_folder_id_here"
DATAIKU_OUTPUT_FOLDER_ID = "output_folder_id_here"

# --- Column Mapping (manually define)
A_cols = ["A1_colname", "A2_colname", "A3_colname", "A4_colname"]
B_cols = ["B1_colname", "B2_colname", "B3_colname", "B4_colname"]

# List of tuples for C columns (column name, category column name)
C_cols = [
    ("C1_colname", "C1_category_colname"),
    ("C2_colname", "C2_category_colname"),
    ("C3_colname", "C3_category_colname"),
    ("C4_colname", "C4_category_colname")
]

# =====================================================
# üß† Helper Functions
# =====================================================

def pick_value(a_val, b_val):
    """Pick A if valid, else B. Return (value, source_tag)."""
    if pd.notna(a_val) and str(a_val).strip().upper() not in ["N/A", "NA", "NONE", "NULL", ""]:
        return a_val, "D-1"
    elif pd.notna(b_val) and str(b_val).strip().upper() not in ["N/A", "NA", "NONE", "NULL", ""]:
        return b_val, "D-4"
    else:
        return np.nan, np.nan


def transform_table(df):
    """Perform A/B comparison and return transformed DataFrame."""
    if not all(col in df.columns for col in ["Category", "Tenor"]):
        raise ValueError("Input file missing 'Category' or 'Tenor' columns.")

    result = df[["Category", "Tenor"]].copy()

    # A/B comparison logic
    for i, (a_col, b_col) in enumerate(zip(A_cols, B_cols), start=1):
        if a_col not in df.columns or b_col not in df.columns:
            result[f"AB{i}"] = np.nan
            result[f"AB{i} Category"] = np.nan
            continue
        values, sources = zip(*[pick_value(a, b) for a, b in zip(df[a_col], df[b_col])])
        result[f"AB{i}"] = values
        result[f"AB{i} Category"] = sources

    # Add C columns
    for i, (c_val, c_cat) in enumerate(C_cols, start=1):
        result[f"C{i}"] = df[c_val] if c_val in df.columns else np.nan
        result[f"C{i} Category"] = df[c_cat] if c_cat in df.columns else np.nan

    return result


def process_file(file_path):
    """Read and transform a single file."""
    filename = os.path.basename(file_path)
    print(f"üîπ Processing: {filename}")

    # Read file
    if file_path.lower().endswith(".csv"):
        df = pd.read_csv(file_path)
    elif file_path.lower().endswith((".xlsx", ".xls")):
        df = pd.read_excel(file_path)
    else:
        raise ValueError("Unsupported file format")

    transformed_df = transform_table(df)
    return transformed_df


# =====================================================
# üöÄ Main Execution
# =====================================================
def main():
    start_time = datetime.now()
    print(f"üöÄ Starting A/B Comparison Processing at {start_time.strftime('%Y-%m-%d %H:%M:%S')}")

    if USE_DATAIKU:
        print("üì¶ Running in Dataiku mode...")
        input_folder_obj = dataiku.Folder(DATAIKU_INPUT_FOLDER_ID)
        output_folder_obj = dataiku.Folder(DATAIKU_OUTPUT_FOLDER_ID)
        input_files = [f for f in input_folder_obj.list_paths_in_partition() if f.lower().endswith((".csv", ".xlsx", ".xls"))]

        if not input_files:
            print("‚ö†Ô∏è No input files found in Dataiku input folder.")
            return

        for file_path in input_files:
            try:
                with input_folder_obj.get_download_stream(file_path) as stream:
                    suffix = ".csv" if file_path.lower().endswith(".csv") else ".xlsx"
                    with tempfile.NamedTemporaryFile(mode="wb", suffix=suffix, delete=False) as tmp_file:
                        tmp_file.write(stream.read())
                        tmp_file_path = tmp_file.name

                transformed_df = process_file(tmp_file_path)

                # Save to temp and upload
                output_name = os.path.splitext(os.path.basename(file_path))[0] + "_final.csv"
                with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False, encoding="utf-8") as tmp_csv:
                    transformed_df.to_csv(tmp_csv.name, index=False)
                    tmp_csv_path = tmp_csv.name

                output_folder_obj.upload_stream(output_name, open(tmp_csv_path, "rb"))
                os.remove(tmp_file_path)
                os.remove(tmp_csv_path)

                print(f"‚úÖ Processed and saved: {output_name}")

            except Exception as e:
                print(f"‚ùå Error processing {file_path}: {e}")

    else:
        print("üíª Running in Local mode...")
        os.makedirs(local_output_folder, exist_ok=True)
        input_files = [f for f in os.listdir(local_input_folder) if f.lower().endswith((".csv", ".xlsx", ".xls"))]

        if not input_files:
            print("‚ö†Ô∏è No input files found in local input folder.")
            return

        for filename in input_files:
            try:
                file_path = os.path.join(local_input_folder, filename)
                transformed_df = process_file(file_path)
                output_name = os.path.splitext(filename)[0] + "_final" + os.path.splitext(filename)[1]
                output_path = os.path.join(local_output_folder, output_name)

                if output_path.lower().endswith(".csv"):
                    transformed_df.to_csv(output_path, index=False)
                else:
                    transformed_df.to_excel(output_path, index=False)

                print(f"‚úÖ Saved locally: {output_path}")

            except Exception as e:
                print(f"‚ùå Error processing {filename}: {e}")

    print(f"üéâ Completed in {(datetime.now() - start_time).total_seconds():.2f}s")


# =====================================================
# üïí Run Script
# =====================================================
if __name__ == "__main__":
    main()
