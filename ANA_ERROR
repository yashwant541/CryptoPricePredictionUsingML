import dataiku
import pandas as pd
import re
import io
from extract_msg import Message
from datetime import datetime

# -----------------------------
# Configuration
# -----------------------------
input_folder_name = "INPUT_FOLDER"   # Dataiku input folder
output_folder_name = "OUTPUT_FOLDER" # Dataiku output folder

# Get Dataiku folder objects
input_folder = dataiku.Folder(input_folder_name)
output_folder = dataiku.Folder(output_folder_name)

# -----------------------------
# Helper Functions
# -----------------------------
def extract_date_from_filename(filename):
    """Extract date from filename and return standardized YYYY-MM-DD"""
    name_without_ext = filename.rsplit('.', 1)[0]
    pattern = r'(\d{1,2}-[A-Za-z]{3}-\d{4})'
    match = re.search(pattern, name_without_ext)
    if match:
        try:
            dt = datetime.strptime(match.group(1), '%d-%b-%Y')
            return dt.strftime('%Y-%m-%d')
        except ValueError:
            pass
    return "unknown_date"

def extract_table_from_html(html_content):
    """Extract table from HTML content using pandas"""
    try:
        tables = pd.read_html(html_content)
        if tables:
            return tables[0]
    except Exception as e:
        print(f"HTML extraction error: {e}")
    return None

def extract_table_from_text(text_content):
    """Extract table from plain text content"""
    lines = text_content.split('\n')
    table_data = []

    for line in lines:
        line = line.strip()
        if not line:
            continue
        if '\t' in line:
            row = [c.strip() for c in line.split('\t') if c.strip()]
        elif ',' in line and len(line.split(',')) > 2:
            row = [c.strip() for c in line.split(',') if c.strip()]
        else:
            row = [c.strip() for c in re.split(r'\s{2,}', line) if c.strip()]
        if len(row) > 1:
            table_data.append(row)

    if len(table_data) > 1:
        try:
            df = pd.DataFrame(table_data[1:], columns=table_data[0])
            return df
        except Exception as e:
            print(f"Text table to DataFrame error: {e}")
    return None

# -----------------------------
# MSG Processing Functions
# -----------------------------
def process_msg_file(msg_bytes, filename):
    """Process a single MSG file from bytes"""
    try:
        with io.BytesIO(msg_bytes) as msg_buffer:
            msg = Message(msg_buffer)
            date_str = extract_date_from_filename(filename)

            # Extract table from HTML first
            df = extract_table_from_html(msg.htmlBody) if msg.htmlBody else None
            # If no table, try text
            if df is None and msg.body:
                df = extract_table_from_text(msg.body)

            if df is not None:
                output_filename = f"{date_str}_table.csv"
                with output_folder.get_writer(output_filename) as writer:
                    df.to_csv(writer, index=False)
                print(f"✓ Saved: {output_filename} | Shape: {df.shape}")
                return True
            else:
                print(f"✗ No table found in {filename}")
                return False
    except Exception as e:
        print(f"Error processing {filename}: {e}")
        return False

def process_all_msg_files():
    """Process all MSG files in the Dataiku input folder"""
    paths = input_folder.list_paths_in_partition()
    msg_files = [p for p in paths if p.lower().endswith(".msg")]

    if not msg_files:
        print("No MSG files found in input folder")
        return

    print(f"Found {len(msg_files)} MSG files")
    success_count = 0
    for i, path in enumerate(msg_files, 1):
        print(f"\n[{i}/{len(msg_files)}] Processing: {path}")
        with input_folder.get_download_stream(path) as f:
            msg_bytes = f.read()
        if process_msg_file(msg_bytes, path):
            success_count += 1

    print("\nProcessing complete!")
    print(f"Successfully extracted tables from {success_count}/{len(msg_files)} files")

# -----------------------------
# Main Execution
# -----------------------------
if __name__ == "__main__":
    process_all_msg_files()
