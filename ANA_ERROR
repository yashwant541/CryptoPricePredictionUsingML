import dataiku
import tempfile
import os
from msg_parser import MsOxMessage
import re
from datetime import datetime
import logging
import traceback

# ------------------------------------------------------
# üîß Configuration
# ------------------------------------------------------
input_folder = dataiku.Folder("YOUR_INPUT_FOLDER_ID")
output_folder = dataiku.Folder("YOUR_OUTPUT_FOLDER_ID")

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

# ------------------------------------------------------
# üöÄ File Type Detection & Extension Mapping
# ------------------------------------------------------
FILE_SIGNATURES = {
    '504B0304': ('xlsx', 'Excel Workbook'),
    '504B0506': ('xlsx', 'Excel Workbook'),  # ZIP empty archive
    '504B0708': ('xlsx', 'Excel Workbook'),  # ZIP spanned archive
    'D0CF11E0': ('xls', 'Excel 97-2003 Workbook'),
    '504B34': ('msg', 'Outlook MSG File'),
    '4D534700': ('msg', 'Outlook MSG File'),
    '89504E47': ('png', 'PNG Image'),
    'FFD8FF': ('jpg', 'JPEG Image'),
    '25504446': ('pdf', 'PDF Document'),
    '504B030414': ('xlsx', 'Excel Workbook'),  # Longer signature for better detection
    '504B030414000600': ('xlsx', 'Excel Workbook'),
}

EXTENSION_MAPPING = {
    'xlsx': 'xlsx',
    'xls': 'xls', 
    'msg': 'msg',
    'pdf': 'pdf',
    'jpg': 'jpg',
    'jpeg': 'jpg',
    'png': 'png',
    'doc': 'doc',
    'docx': 'docx',
    'ppt': 'ppt',
    'pptx': 'pptx',
    'txt': 'txt',
    'csv': 'csv'
}

# ------------------------------------------------------
# üöÄ Helper Functions
# ------------------------------------------------------
def extract_date_from_filename(filename):
    """
    Extract first date in format DD-MMM-YYYY (like 23-Sep-2024) from filename.
    Returns date string if found, else uses current date.
    """
    pattern = r'(\d{1,2}-[A-Za-z]{3}-\d{4})'
    match = re.search(pattern, filename)
    if match:
        return match.group(1)
    return datetime.now().strftime("%d-%b-%Y")

def sanitize_filename(filename):
    """
    Remove or replace characters that might be problematic in filenames.
    """
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    return filename

def get_attachment_name(attachment, index):
    """
    Safely extract attachment name with fallbacks.
    """
    attach_name = (getattr(attachment, "long_fname", None) or 
                   getattr(attachment, "filename", None) or 
                   f"attachment_{index}")
    return sanitize_filename(attach_name)

def detect_file_type_from_bytes(file_bytes):
    """
    Detect file type from byte signature and return proper extension.
    """
    if not file_bytes or len(file_bytes) < 4:
        return "dat", "Unknown"
    
    hex_signature = file_bytes[:8].hex().upper()
    
    # Check for exact matches first
    for signature, (ext, description) in FILE_SIGNATURES.items():
        if hex_signature.startswith(signature):
            return ext, description
    
    # Check for partial matches
    for signature, (ext, description) in FILE_SIGNATURES.items():
        if signature.startswith(hex_signature) or hex_signature.startswith(signature):
            return ext, description
    
    return "dat", "Unknown Binary"

def get_proper_extension(attachment_name, file_bytes):
    """
    Determine the proper file extension using multiple methods.
    """
    # Method 1: Try to get extension from original filename
    original_ext = os.path.splitext(attachment_name)[1].lower().lstrip('.')
    if original_ext in EXTENSION_MAPPING:
        return EXTENSION_MAPPING[original_ext]
    
    # Method 2: Detect from file signature
    detected_ext, description = detect_file_type_from_bytes(file_bytes)
    
    # Method 3: If it's a ZIP file (Excel), check if we should use xlsx
    if detected_ext == 'xlsx' and original_ext in ['xls', 'xlsx']:
        return original_ext
    
    return detected_ext if detected_ext != "dat" else "bin"

def extract_attachment_data(attachment):
    """
    Enhanced attachment data extraction with multiple fallback methods.
    """
    # Method 1: Try payload first
    attach_bytes = getattr(attachment, "payload", None)
    if attach_bytes and len(attach_bytes) > 0:
        return attach_bytes
    
    # Method 2: Try _get_stream_data method
    if hasattr(attachment, '_get_stream_data'):
        try:
            stream_data = attachment._get_stream_data()
            if stream_data and len(stream_data) > 0:
                return stream_data
        except:
            pass
    
    # Method 3: Try data property
    attach_bytes = getattr(attachment, "data", None)
    if attach_bytes and len(attach_bytes) > 0:
        return attach_bytes
    
    # Method 4: Try _get_string_stream for text
    if hasattr(attachment, '_get_string_stream'):
        try:
            string_data = attachment._get_string_stream()
            if string_data:
                return string_data.encode('utf-8')
        except:
            pass
    
    return None

def diagnose_issues():
    """
    Run comprehensive diagnostics to identify problems.
    """
    print("üîç RUNNING ENHANCED DIAGNOSTICS üîç")
    
    try:
        input_files = input_folder.list_paths_in_partition()
        print(f"‚úÖ Input folder accessible - {len(input_files)} files found")
        
        msg_files = [f for f in input_files if f.lower().endswith('.msg')]
        print(f"üìß .msg files found: {len(msg_files)}")
        
        if not msg_files:
            print("‚ùå No .msg files found!")
            return False
        
        # Test first file
        first_file = msg_files[0]
        print(f"\nüîÆ Testing: {first_file}")
        
        with input_folder.get_download_stream(first_file) as stream:
            content = stream.read()
            print(f"‚úÖ Downloaded: {len(content)} bytes")
        
        with tempfile.NamedTemporaryFile(delete=False, suffix=".msg") as tmp:
            tmp.write(content)
            tmp_path = tmp.name
        
        try:
            msg = MsOxMessage(tmp_path)
            attachments = list(msg.attachments)
            print(f"‚úÖ Parsed successfully: {len(attachments)} attachments")
            
            for i, attach in enumerate(attachments):
                attach_name = get_attachment_name(attach, i+1)
                original_ext = os.path.splitext(attach_name)[1].lower().lstrip('.') or "none"
                print(f"\nüìé Attachment {i+1}:")
                print(f"   Name: {attach_name}")
                print(f"   Original extension: {original_ext}")
                
                attach_bytes = extract_attachment_data(attach)
                
                if attach_bytes:
                    print(f"   Data extracted: {len(attach_bytes)} bytes")
                    
                    # Detect file type
                    hex_sig = attach_bytes[:8].hex().upper()
                    detected_ext, file_type = detect_file_type_from_bytes(attach_bytes)
                    proper_ext = get_proper_extension(attach_name, attach_bytes)
                    
                    print(f"   File signature: {hex_sig}")
                    print(f"   Detected type: {file_type} ({detected_ext})")
                    print(f"   Final extension: {proper_ext}")
                    
                    # Show available attributes
                    attrs = [attr for attr in dir(attach) if not attr.startswith('_') and not callable(getattr(attach, attr))]
                    print(f"   Available attributes: {attrs}")
                    
                else:
                    print(f"   ‚ùå No data extracted")
                    
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Diagnostics failed: {e}")
        traceback.print_exc()
        return False

# ------------------------------------------------------
# üöÄ Main Processing Function
# ------------------------------------------------------
def process_msg_files():
    """
    Main function to process all .msg files and extract attachments with proper extensions.
    """
    try:
        input_files = input_folder.list_paths_in_partition()
        if not input_files:
            logger.warning("‚ö†Ô∏è No files found in input folder!")
            return 0, 0

        msg_files = [f for f in input_files if f.lower().endswith('.msg')]
        if not msg_files:
            logger.warning("‚ö†Ô∏è No .msg files found!")
            return 0, 0

        logger.info(f"üìß Found {len(msg_files)} .msg files to process")
        processed_count = 0
        total_attachments = 0

        for msg_file_path in msg_files:
            msg_filename = os.path.basename(msg_file_path)
            email_date = extract_date_from_filename(msg_filename)
            
            logger.info(f"üîç Processing: {msg_filename}")

            # Download .msg file
            with input_folder.get_download_stream(msg_file_path) as stream:
                with tempfile.NamedTemporaryFile(delete=False, suffix=".msg") as tmp_msg:
                    tmp_msg.write(stream.read())
                    tmp_msg_path = tmp_msg.name

            try:
                msg = MsOxMessage(tmp_msg_path)
                
                if not msg.attachments:
                    logger.info(f"üì≠ No attachments found in {msg_filename}")
                    continue

                logger.info(f"üìé Found {len(msg.attachments)} attachments")
                file_attachment_count = 0

                for i, attachment in enumerate(msg.attachments, start=1):
                    attach_name = get_attachment_name(attachment, i)
                    attach_bytes = extract_attachment_data(attachment)

                    if not attach_bytes or len(attach_bytes) == 0:
                        logger.warning(f"‚è© Skipping empty attachment {i}: {attach_name}")
                        continue

                    # Get proper file extension
                    original_ext = os.path.splitext(attach_name)[1].lower().lstrip('.')
                    proper_ext = get_proper_extension(attach_name, attach_bytes)
                    
                    # Get base name without extension
                    base_name = os.path.splitext(attach_name)[0]
                    if not base_name or base_name == attach_name:
                        base_name = f"attachment_{i}"
                    
                    # Create final filename
                    safe_base_name = sanitize_filename(base_name)
                    output_file_name = f"{email_date}_{safe_base_name}_{i}.{proper_ext}"

                    # Save and upload
                    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                        tmp_file.write(attach_bytes)
                        tmp_file_path_attach = tmp_file.name

                    try:
                        with open(tmp_file_path_attach, "rb") as f:
                            output_folder.upload_stream(output_file_name, f)
                        
                        # Log file type info
                        hex_sig = attach_bytes[:8].hex().upper()
                        detected_ext, file_type = detect_file_type_from_bytes(attach_bytes)
                        
                        logger.info(f"‚úÖ Saved: {output_file_name}")
                        logger.info(f"   üìä Type: {file_type}, Size: {len(attach_bytes)} bytes, Signature: {hex_sig}")
                        
                        file_attachment_count += 1
                        total_attachments += 1
                        
                    except Exception as upload_error:
                        logger.error(f"‚ùå Upload failed for {output_file_name}: {upload_error}")
                    finally:
                        if os.path.exists(tmp_file_path_attach):
                            os.remove(tmp_file_path_attach)

                logger.info(f"üéâ {msg_filename}: {file_attachment_count} attachments extracted")
                processed_count += 1

            except Exception as msg_error:
                logger.error(f"‚ùå Error processing {msg_filename}: {msg_error}")
                traceback.print_exc()
            finally:
                if os.path.exists(tmp_msg_path):
                    os.remove(tmp_msg_path)

        logger.info(f"üéâ Complete! {processed_count} files processed, {total_attachments} attachments extracted")
        return processed_count, total_attachments

    except Exception as e:
        logger.error(f"üí• Critical error: {e}")
        traceback.print_exc()
        return 0, 0

# ------------------------------------------------------
# üéØ Main Execution
# ------------------------------------------------------
if __name__ == "__main__":
    print("=" * 60)
    print("üìß SMART MSG Attachment Extractor")
    print("=" * 60)
    
    print("\nüöÄ Starting diagnostics...")
    if diagnose_issues():
        print("\n‚úÖ Diagnostics passed! Starting processing...")
        print("-" * 40)
        
        processed_count, total_attachments = process_msg_files()
        
        print("-" * 40)
        if processed_count > 0:
            print(f"üéä Success! Processed {processed_count} files, extracted {total_attachments} attachments")
        else:
            print("‚ùå Processing failed")
    else:
        print("\n‚ùå Diagnostics failed!")
    
    print("=" * 60)
