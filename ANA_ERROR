import dataiku
import tempfile
import os
from msg_parser import MsOxMessage
import re
from datetime import datetime
import logging
import traceback

# ------------------------------------------------------
# üîß Configuration
# ------------------------------------------------------
input_folder = dataiku.Folder("YOUR_INPUT_FOLDER_ID")
output_folder = dataiku.Folder("YOUR_OUTPUT_FOLDER_ID")

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

# ------------------------------------------------------
# üöÄ Helper Functions
# ------------------------------------------------------
def extract_date_from_filename(filename):
    """
    Extract first date in format DD-MMM-YYYY (like 23-Sep-2024) from filename.
    Returns date string if found, else uses current date.
    """
    pattern = r'(\d{1,2}-[A-Za-z]{3}-\d{4})'
    match = re.search(pattern, filename)
    if match:
        return match.group(1)
    # Fallback to current date if no date in filename
    return datetime.now().strftime("%d-%b-%Y")

def sanitize_filename(filename):
    """
    Remove or replace characters that might be problematic in filenames.
    """
    # Remove invalid characters for filenames
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    return filename

def get_attachment_name(attachment, index):
    """
    Safely extract attachment name with fallbacks.
    """
    attach_name = (getattr(attachment, "long_fname", None) or 
                   getattr(attachment, "filename", None) or 
                   f"attachment_{index}")
    return sanitize_filename(attach_name)

def extract_attachment_data(attachment):
    """
    Enhanced attachment data extraction with multiple fallback methods.
    """
    # Method 1: Try payload first
    attach_bytes = getattr(attachment, "payload", None)
    if attach_bytes and len(attach_bytes) > 0:
        return attach_bytes
    
    # Method 2: Try _get_stream_data method (common in msg_parser)
    if hasattr(attachment, '_get_stream_data'):
        try:
            stream_data = attachment._get_stream_data()
            if stream_data and len(stream_data) > 0:
                return stream_data
        except:
            pass
    
    # Method 3: Try data property
    attach_bytes = getattr(attachment, "data", None)
    if attach_bytes and len(attach_bytes) > 0:
        return attach_bytes
    
    # Method 4: Try _get_string_stream method for text content
    if hasattr(attachment, '_get_string_stream'):
        try:
            string_data = attachment._get_string_stream()
            if string_data:
                return string_data.encode('utf-8')
        except:
            pass
    
    return None

def diagnose_issues():
    """
    Run comprehensive diagnostics to identify problems.
    """
    print("üîç RUNNING DIAGNOSTICS üîç")
    
    # 1. Check folder access
    print("\n1. üìÅ Checking folder access...")
    try:
        input_files = input_folder.list_paths_in_partition()
        print(f"   ‚úÖ Input folder accessible")
        print(f"   üìä Files found: {len(input_files)}")
        for i, file_path in enumerate(input_files[:5]):
            print(f"      {i+1}. {file_path}")
        if len(input_files) > 5:
            print(f"      ... and {len(input_files) - 5} more files")
    except Exception as e:
        print(f"   ‚ùå Input folder error: {e}")
        return False
    
    # 2. Check for .msg files
    print("\n2. üìß Checking for .msg files...")
    msg_files = [f for f in input_files if f.lower().endswith('.msg')]
    print(f"   üìß .msg files found: {len(msg_files)}")
    
    if not msg_files:
        print("   ‚ùå No .msg files found!")
        all_extensions = set(os.path.splitext(f)[1].lower() for f in input_files if os.path.splitext(f)[1])
        print(f"   üìä All file extensions in folder: {all_extensions}")
        return False
    
    for i, msg_file in enumerate(msg_files):
        print(f"      {i+1}. {msg_file}")
    
    # 3. Test first .msg file with detailed attachment analysis
    print("\n3. üîÆ Testing first .msg file with attachment analysis...")
    first_file = msg_files[0]
    try:
        with input_folder.get_download_stream(first_file) as stream:
            content = stream.read()
            print(f"   ‚úÖ File downloaded: {len(content)} bytes")
            
        if len(content) == 0:
            print("   ‚ùå File is empty!")
            return False
            
        with tempfile.NamedTemporaryFile(delete=False, suffix=".msg") as tmp:
            tmp.write(content)
            tmp_path = tmp.name
        
        try:
            msg = MsOxMessage(tmp_path)
            attachments = list(msg.attachments)
            print(f"   ‚úÖ Parsing successful: {len(attachments)} attachments found")
            
            # Detailed attachment analysis
            for i, attach in enumerate(attachments):
                attach_name = get_attachment_name(attach, i+1)
                print(f"\n      üìé Attachment {i+1}: {attach_name}")
                
                # Check all available attributes
                print(f"         Available attributes: {[attr for attr in dir(attach) if not attr.startswith('_')]}")
                
                # Try multiple extraction methods
                attach_bytes = extract_attachment_data(attach)
                
                if attach_bytes:
                    print(f"         ‚úÖ Data extracted: {len(attach_bytes)} bytes")
                    # Check file signature
                    if len(attach_bytes) >= 4:
                        file_sig = attach_bytes[:4].hex().upper()
                        print(f"         üîç File signature: {file_sig}")
                        
                        # Common file signatures
                        signatures = {
                            '504B0304': 'ZIP (Excel, Word, etc)',
                            'D0CF11E0': 'Microsoft Office (older)',
                            '504B34': 'MSG file',
                            '4D534700': 'MSG file alternative',
                            '89504E47': 'PNG image',
                            'FFD8FF': 'JPEG image',
                            '25504446': 'PDF file'
                        }
                        
                        for sig, file_type in signatures.items():
                            if file_sig.startswith(sig.lower()) or file_sig.startswith(sig.upper()):
                                print(f"         üìÑ File type detected: {file_type}")
                                break
                else:
                    print(f"         ‚ùå No data could be extracted")
                    
                # Check specific properties
                for prop in ['size', 'get_size', 'data_size']:
                    if hasattr(attach, prop):
                        size_val = getattr(attach, prop)
                        print(f"         {prop}: {size_val}")
                
        except Exception as parse_error:
            print(f"   ‚ùå MSG parsing failed: {parse_error}")
            traceback.print_exc()
            return False
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)
        
        return True
        
    except Exception as e:
        print(f"   ‚ùå File test failed: {e}")
        traceback.print_exc()
        return False

# ------------------------------------------------------
# üöÄ Main Processing Function
# ------------------------------------------------------
def process_msg_files():
    """
    Main function to process all .msg files and extract attachments.
    """
    try:
        # Get all files from input folder
        input_files = input_folder.list_paths_in_partition()
        if not input_files:
            logger.warning("‚ö†Ô∏è No files found in input folder!")
            return 0

        # Filter for .msg files (case insensitive)
        msg_files = [f for f in input_files if f.lower().endswith('.msg')]
        
        if not msg_files:
            logger.warning("‚ö†Ô∏è No .msg files found in input folder!")
            return 0

        logger.info(f"üìß Found {len(msg_files)} .msg files to process")
        processed_count = 0
        total_attachments_extracted = 0

        for msg_file_path in msg_files:
            msg_filename = os.path.basename(msg_file_path)
            email_date = extract_date_from_filename(msg_filename)
            
            logger.info(f"üîç Processing: {msg_filename}")

            # Download .msg file to temporary location
            with input_folder.get_download_stream(msg_file_path) as stream:
                with tempfile.NamedTemporaryFile(delete=False, suffix=".msg") as tmp_msg:
                    tmp_msg.write(stream.read())
                    tmp_msg_path = tmp_msg.name

            try:
                # Parse .msg file
                msg = MsOxMessage(tmp_msg_path)
                
                if not msg.attachments:
                    logger.info(f"üì≠ No attachments found in {msg_filename}")
                    continue

                logger.info(f"üìé Found {len(msg.attachments)} attachments in {msg_filename}")
                attachment_count = 0

                for i, attachment in enumerate(msg.attachments, start=1):
                    attach_name = get_attachment_name(attachment, i)
                    
                    # Enhanced attachment data extraction
                    attach_bytes = extract_attachment_data(attachment)

                    if not attach_bytes:
                        logger.warning(f"‚è© Skipping empty attachment {i}: {attach_name}")
                        # Debug info for empty attachments
                        if hasattr(attachment, 'size'):
                            logger.debug(f"    Attachment size property: {attachment.size}")
                        continue

                    if len(attach_bytes) == 0:
                        logger.warning(f"‚è© Skipping zero-byte attachment {i}: {attach_name}")
                        continue

                    # Get file extension
                    base_name, ext_with_dot = os.path.splitext(attach_name)
                    ext = ext_with_dot.lower().lstrip('.') or "dat"
                    
                    # Construct unique output filename
                    safe_base_name = sanitize_filename(base_name)
                    output_file_name = f"{email_date}_{safe_base_name}_{i}.{ext}"

                    # Save temporary file
                    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                        tmp_file.write(attach_bytes)
                        tmp_file_path_attach = tmp_file.name

                    # Upload to Dataiku output folder
                    try:
                        with open(tmp_file_path_attach, "rb") as f:
                            output_folder.upload_stream(output_file_name, f)
                        logger.info(f"‚úÖ Saved: {output_file_name} ({len(attach_bytes)} bytes)")
                        attachment_count += 1
                        total_attachments_extracted += 1
                    except Exception as upload_error:
                        logger.error(f"‚ùå Failed to upload {output_file_name}: {upload_error}")
                    finally:
                        # Cleanup temporary attachment file
                        if os.path.exists(tmp_file_path_attach):
                            os.remove(tmp_file_path_attach)

                logger.info(f"üéâ Processed {msg_filename}: {attachment_count}/{len(msg.attachments)} attachments extracted")
                processed_count += 1

            except Exception as msg_error:
                logger.error(f"‚ùå Error processing {msg_filename}: {msg_error}")
                traceback.print_exc()
            finally:
                # Cleanup temporary .msg file
                if os.path.exists(tmp_msg_path):
                    os.remove(tmp_msg_path)

        logger.info(f"üéâ Processing complete! {processed_count}/{len(msg_files)} .msg files processed, {total_attachments_extracted} total attachments extracted!")
        return processed_count

    except Exception as e:
        logger.error(f"üí• Critical error in main execution: {e}")
        traceback.print_exc()
        return 0

# ------------------------------------------------------
# üéØ Main Execution
# ------------------------------------------------------
if __name__ == "__main__":
    print("=" * 60)
    print("üìß MSG Attachment Extractor - Enhanced Version")
    print("=" * 60)
    
    # Step 1: Run diagnostics
    print("\nüöÄ Starting enhanced diagnostics...")
    diagnostic_passed = diagnose_issues()
    
    if diagnostic_passed:
        print("\n‚úÖ Diagnostics passed! Starting main processing...")
        print("-" * 40)
        
        # Step 2: Process files
        processed_count = process_msg_files()
        
        print("-" * 40)
        if processed_count > 0:
            print(f"üéä Successfully processed {processed_count} files!")
        else:
            print("‚ùå No files were processed. Check the logs above for errors.")
    else:
        print("\n‚ùå Diagnostics failed! Please fix the issues above before processing.")
    
    print("=" * 60)
