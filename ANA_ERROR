import pandas as pd
import dataiku
import tempfile
import os

# ------------------------------------------------------
# 🔧 Configuration — Replace with your Dataiku folder IDs
# ------------------------------------------------------
input_folder = dataiku.Folder("XXXXXXXXX")      # 📥 Input folder
output_folder = dataiku.Folder("XXXXXXXXX")     # 📤 Output folder

label_column = "Label"  # 🏷️ Column to split

# ------------------------------------------------------
# 🧠 Per-file split configurations
# ------------------------------------------------------
file_config = {
    # filename (without extension): {split lengths + new column names}
    "file1": {"split_lengths": [2, 3], "col_names": ["Country", "Time"]},
    "file2": {"split_lengths": [3, 2, 1], "col_names": ["Region", "Zone", "Type"]},
    "file3": {"split_lengths": [4], "col_names": ["Code"]},
    # Add more if needed
}

# ------------------------------------------------------
# 🧩 Label splitting logic
# ------------------------------------------------------
def split_label(label, split_lengths):
    """
    Splits from left based on split_lengths.
    Stops at '=' and captures only part before it.
    Anything remaining (variable length) before '=' becomes the 'Remaining' column.
    """
    text = str(label).split("=")[0]  # take only part before '='
    parts, start = [], 0

    for length in split_lengths:
        parts.append(text[start:start + length])
        start += length

    # Remaining part before '='
    remaining = text[start:] if start < len(text) else ""
    parts.append(remaining)
    return parts

# ------------------------------------------------------
# 🚀 Main Execution
# ------------------------------------------------------
def main():
    input_files = input_folder.list_paths_in_partition()
    if not input_files:
        raise FileNotFoundError("❌ No files found in input folder!")

    for file_info in input_files:
        file_name = os.path.basename(file_info)
        base_name, ext = os.path.splitext(file_name)

        print(f"📄 Processing file: {file_name}")

        if base_name not in file_config:
            print(f"⚠️ No configuration found for {base_name}. Skipping this file.")
            continue

        # 🧾 Get configuration for this file
        cfg = file_config[base_name]
        split_lengths = cfg["split_lengths"]
        col_names = cfg["col_names"] + ["Remaining"]

        # -------------------------------
        # 📥 Read file to temporary path
        # -------------------------------
        with input_folder.get_download_stream(file_info) as stream:
            with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
                tmp.write(stream.read())
                tmp_path = tmp.name

        # Read data depending on file type
        if ext.lower() == ".csv":
            df = pd.read_csv(tmp_path)
        elif ext.lower() in [".xls", ".xlsx"]:
            df = pd.read_excel(tmp_path)
        else:
            print(f"⚠️ Skipping unsupported file type: {file_name}")
            os.remove(tmp_path)
            continue

        # -------------------------------
        # 🧩 Apply splitting logic
        # -------------------------------
        if label_column not in df.columns:
            print(f"⚠️ Column '{label_column}' not found in {file_name}. Skipping.")
            os.remove(tmp_path)
            continue

        split_df = df[label_column].apply(lambda x: pd.Series(split_label(x, split_lengths), index=col_names))
        final_df = pd.concat([df, split_df], axis=1)

        # -------------------------------
        # 💾 Save to output folder
        # -------------------------------
        with tempfile.NamedTemporaryFile(mode="w+b", suffix=ext, delete=False) as tmp_out:
            if ext.lower() == ".csv":
                final_df.to_csv(tmp_out.name, index=False, encoding="utf-8-sig")
            else:
                final_df.to_excel(tmp_out.name, index=False)

            with open(tmp_out.name, "rb") as f:
                output_folder.upload_stream(file_name, f)

        os.remove(tmp_path)
        os.remove(tmp_out.name)
        print(f"✅ Processed and saved: {file_name}")

    print("🎯 All files processed successfully!")

# ------------------------------------------------------
if __name__ == "__main__":
    main()
