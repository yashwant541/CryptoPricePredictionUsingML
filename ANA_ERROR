import pandas as pd
import dataiku
import os
import io

# ------------------------------------------------------
# ‚öôÔ∏è CONFIGURATION (EDIT BELOW)
# ------------------------------------------------------

input_folder = dataiku.Folder("INPUT_FOLDER_ID")      # üîÑ Replace with your input folder ID
output_folder = dataiku.Folder("OUTPUT_FOLDER_ID")    # üîÑ Replace with your output folder ID

# üß† Define per-file configurations
file_config = {
    "file1.csv": {
        "label_column": "Label",
        "split_lengths": [2, 3, 2, 4],
        "col_names": ["Part1", "Part2", "Part3", "Remaining"]
    },
    "file2.csv": {
        "label_column": "ProductCode",
        "split_lengths": [3, 2, 5],
        "col_names": ["Prefix", "Batch", "Tail"]
    },
    "file3.xlsx": {
        "label_column": "Identifier",
        "split_lengths": [1, 2, 2, 3],
        "col_names": ["SecA", "SecB", "SecC", "Rest"]
    },
    "file4.csv": {
        "label_column": "Code",
        "split_lengths": [4, 4],
        "col_names": ["Head", "Tail"]
    },
    "file5.csv": {
        "label_column": "Reference",
        "split_lengths": [2, 2, 2, 2, 2],
        "col_names": ["S1", "S2", "S3", "S4", "Remaining"]
    }
}

# Default config if file not in list
default_label_column = "Label"
default_split_lengths = [2, 3, 2, 4]
default_col_names = ["Part1", "Part2", "Part3", "Remaining"]

# ------------------------------------------------------
# üß© FUNCTION
# ------------------------------------------------------

def split_label(label, split_lengths, col_names):
    """
    Removes text after first '=', then splits remaining part from left 
    according to the given split_lengths. 
    """
    label = str(label)
    if "=" in label:
        clean_label = label.split("=")[0]  # stop at first '='
    else:
        clean_label = label

    parts, start = [], 0

    for i, length in enumerate(split_lengths):
        if i < len(split_lengths) - 1:
            parts.append(clean_label[start:start + length])
            start += length
        else:
            parts.append(clean_label[start:])  # remaining text

    # Pad with blanks if not enough text
    while len(parts) < len(col_names):
        parts.append("")

    return dict(zip(col_names, parts))


# ------------------------------------------------------
# üìÇ PROCESS FILES IN INPUT FOLDER
# ------------------------------------------------------

file_list = input_folder.list_paths_in_partition()
print(f"Found {len(file_list)} files to process.\n")

for path in file_list:
    filename = os.path.basename(path)
    print(f"‚öôÔ∏è Processing file: {filename}")

    # üîç Choose config for current file
    config = None
    for key in file_config.keys():
        if key.lower() in filename.lower():  # substring match
            config = file_config[key]
            break

    if config is None:
        print(f"‚ö†Ô∏è No specific config for {filename}, using default.")
        config = {
            "label_column": default_label_column,
            "split_lengths": default_split_lengths,
            "col_names": default_col_names
        }

    label_column = config["label_column"]
    split_lengths = config["split_lengths"]
    col_names = config["col_names"]

    # ------------------------------------------------------
    # üì• READ FILE
    # ------------------------------------------------------
    with input_folder.get_download_stream(filename) as f:
        if filename.lower().endswith(".csv"):
            df = pd.read_csv(f)
        elif filename.lower().endswith((".xls", ".xlsx")):
            df = pd.read_excel(f)
        else:
            print(f"‚ö†Ô∏è Unsupported file type, skipping: {filename}")
            continue

    # ------------------------------------------------------
    # üß© APPLY SPLITTING
    # ------------------------------------------------------
    if label_column not in df.columns:
        print(f"‚ö†Ô∏è Column '{label_column}' not found in {filename}. Skipping.")
        continue

    split_df = df[label_column].apply(lambda x: pd.Series(split_label(x, split_lengths, col_names)))
    final_df = pd.concat([df, split_df], axis=1)

    # ------------------------------------------------------
    # üíæ SAVE TO OUTPUT FOLDER
    # ------------------------------------------------------
    temp_path = os.path.join("/tmp", filename)
    if filename.lower().endswith(".csv"):
        final_df.to_csv(temp_path, index=False, encoding="utf-8-sig")
    else:
        final_df.to_excel(temp_path, index=False)

    with open(temp_path, "rb") as f:
        output_folder.upload_stream(filename, f)

    print(f"‚úÖ Saved processed file: {filename}\n")

print("üéØ All files processed successfully.")
