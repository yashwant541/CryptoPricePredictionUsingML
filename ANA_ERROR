# ============================================================
#      NOMINEE NAME VALIDATION (DATAIKU VERSION)
#      FULL VERSION WITH NAME SIMILARITY CHECK
# ============================================================

import dataiku
import pandas as pd
import re
from rapidfuzz import fuzz

# ------------------------------------------------------------
# READ INPUT DATASET
# ------------------------------------------------------------
input_ds = dataiku.Dataset("input_dataset")   # <-- change to your input dataset
df = input_ds.get_dataframe()

# Required columns
REL_COL = "relationship_no"
ACC_COL = "account_no"
NOM_COL = "name"                   # nominee name
ACC_HOLDER_COL = "account_holder_name"  # account holder name (for similarity check)

# ------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------

def is_one_word_name(name):
    if not isinstance(name, str):
        return False
    parts = name.strip().split()
    return len(parts) == 1 and len(parts[0]) >= 2

# Random / keyboard / nonsense words
RANDOM_WORDS = {"nomination","nominee","nominatn","nominated","qwerty","asdf","zxcv","xyz","abc","abcd","lmnop"}
GIBBERISH_PATTERN = re.compile(r"^[A-Za-z]{5,}$")
VOWEL_RATIO_THRESHOLD = 0.10

def is_random_or_nonsense(name):
    if not isinstance(name, str):
        return False
    clean = name.strip().lower()
    if clean in RANDOM_WORDS:
        return True
    if len(set(clean)) == 1 and len(clean) >= 3:
        return True
    if GIBBERISH_PATTERN.match(clean):
        vowels = sum(ch in "aeiou" for ch in clean)
        if vowels / (len(clean)+1e-6) < VOWEL_RATIO_THRESHOLD:
            return True
    return False

# Relationship words
RELATIONSHIP_WORDS = [
    "mother","mom","mummy","mamma","ma",
    "father","dad","daddy","papa",
    "son","daughter","child","children",
    "wife","husband","spouse",
    "brother","sister","sibling",
    "uncle","aunty","aunt","nephew","niece",
    "grandmother","grandfather","grandma","grandpa",
    "guardian","caretaker"
]

# Keyboard/random words
KEYBOARD_RANDOM = ["qwerty","asdf","zxcv","xyz"]

# ------------------------------------------------------------
# NAME SIMILARITY CHECK FUNCTION
# ------------------------------------------------------------
def name_similarity_issues(nominee_name, account_holder_name):
    issues = []
    if not isinstance(nominee_name, str) or not isinstance(account_holder_name, str):
        return issues
    nominee_clean = nominee_name.lower().strip()
    account_clean = account_holder_name.lower().strip()
    account_tokens = account_clean.split()

    # Substring token check
    for token in account_tokens:
        if token in nominee_clean:
            issues.append(f"Account holder name token '{token}' found in nominee name")
            break

    # Fuzzy full similarity
    ratio = fuzz.partial_ratio(account_clean, nominee_clean)
    if ratio >= 80:
        issues.append(f"High similarity to account holder name ({ratio}%)")

    # Token-wise fuzzy similarity
    for token in account_tokens:
        score = fuzz.partial_ratio(token, nominee_clean)
        if score >= 85:
            issues.append(f"Token-level fuzzy similarity ({token}: {score}%)")
            break
    return issues

# ------------------------------------------------------------
# MAIN VALIDATION FUNCTION
# ------------------------------------------------------------
def validate_nominee_name(nominee_name):
    issues = []

    if not isinstance(nominee_name, str) or not nominee_name.strip():
        issues.append("Missing or empty name")
        return issues

    clean_name = nominee_name.strip()
    lower_name = clean_name.lower()

    # 1. Placeholder values
    PLACEHOLDERS = ["na","n/a","none","null","-","--","nominee","self","unknown"]
    if lower_name in PLACEHOLDERS:
        issues.append("Placeholder / invalid word")

    # 2. One-word name
    if is_one_word_name(clean_name):
        issues.append("One-word name (possibly incomplete)")

    # 3. Digits
    if re.search(r"\d", clean_name):
        issues.append("Contains digits")

    # 4. Special characters except . ' -
    if re.search(r"[^\w\s.'-]", clean_name):
        issues.append("Contains special characters")

    # 5. Initial-only
    if re.fullmatch(r"[A-Za-z]\.?", clean_name):
        issues.append("Initials only")

    # 6. Random / nonsense
    if is_random_or_nonsense(clean_name):
        issues.append("Random or nonsensical name")

    # 7. Keyboard/random text
    for kb in KEYBOARD_RANDOM:
        if kb in lower_name:
            issues.append(f"Random keyboard-like text found ({kb})")
            break

    # 8. NOM wildcard pattern
    if "nom" in lower_name:
        issues.append("Contains 'NOM' pattern (*nom*)")

    # 9. Relationship words
    for rel in RELATIONSHIP_WORDS:
        if re.search(rf"\b{rel}\b", lower_name):
            issues.append(f"Relationship word used instead of name ({rel})")
            break

    # 10. Too short / too long
    if len(clean_name) < 2:
        issues.append("Name too short")
    if len(clean_name) > 70:
        issues.append("Name too long")

    return issues

# ------------------------------------------------------------
# APPLY VALIDATION TO DATAFRAME
# ------------------------------------------------------------
df["nominee_issues"] = df.apply(lambda x: validate_nominee_name(x[NOM_COL]) + 
                                name_similarity_issues(x[NOM_COL], x[ACC_HOLDER_COL]), axis=1)
df["issue_count"] = df["nominee_issues"].apply(len)

# Boolean flags
df["has_nom_pattern"]       = df["nominee_issues"].apply(lambda x: any("NOM" in i.upper() for i in x))
df["has_relationship_word"] = df["nominee_issues"].apply(lambda x: any("Relationship word" in i for i in x))
df["is_nonsense"]           = df["nominee_issues"].apply(lambda x: any("Random or nonsensical" in i for i in x))
df["is_one_word"]           = df["nominee_issues"].apply(lambda x: any("One-word name" in i for i in x))
df["has_digits"]            = df["nominee_issues"].apply(lambda x: any("Contains digits" in i for i in x))
df["has_special_chars"]     = df["nominee_issues"].apply(lambda x: any("special characters" in i for i in x))
df["is_initial_only"]       = df["nominee_issues"].apply(lambda x: any("Initials only" in i for i in x))
df["is_placeholder"]        = df["nominee_issues"].apply(lambda x: any("Placeholder" in i for i in x))
df["is_missing"]            = df["nominee_issues"].apply(lambda x: any("Missing" in i for i in x))
df["has_similarity"]        = df["nominee_issues"].apply(lambda x: any("similarity" in i.lower() for i in x))

# ------------------------------------------------------------
# WRITE OUTPUT DATASET
# ------------------------------------------------------------
output_ds = dataiku.Dataset("output_dataset")  # <-- change dataset name
output_ds.write_with_schema(df)
