import os
import io
import tempfile
import extract_msg
from datetime import datetime

# Try importing Dataiku (skip if running locally)
try:
    import dataiku
except ImportError:
    dataiku = None

# =====================================================
# ‚öôÔ∏è CONFIGURATION
# =====================================================
USE_DATAIKU = True  # üîÅ Toggle between Dataiku (True) or Local (False)

# --- Local paths (used if USE_DATAIKU = False)
local_input_folder = r"C:\Users\YourName\Desktop\Emails\Input"
local_output_folder = r"C:\Users\YourName\Desktop\Emails\Output"

# --- Dataiku folder IDs (used if USE_DATAIKU = True)
DATAIKU_INPUT_FOLDER_ID = "input_folder_id_here"
DATAIKU_OUTPUT_FOLDER_ID = "output_folder_id_here"


# =====================================================
# üß† Helper Function
# =====================================================
def extract_email_body(file_content: bytes) -> str:
    """Extract plain text body from .msg file bytes."""
    with io.BytesIO(file_content) as f:
        msg = extract_msg.Message(f)
        body = msg.body or msg.bodyText or ""
        return body.replace("\r", "").replace("\x00", "")


# =====================================================
# üöÄ Main Execution
# =====================================================
def process_emails():
    if USE_DATAIKU:
        print("üì¶ Running in Dataiku mode...")

        input_folder = dataiku.Folder(DATAIKU_INPUT_FOLDER_ID)
        output_folder = dataiku.Folder(DATAIKU_OUTPUT_FOLDER_ID)
        file_list = input_folder.list_paths_in_partition()

        if not file_list:
            print("‚ö†Ô∏è No files found in Dataiku input folder.")
            return

        for file_path in file_list:
            if not file_path.lower().endswith(".msg"):
                continue

            try:
                # Read .msg file bytes
                with input_folder.get_download_stream(file_path) as stream:
                    file_bytes = stream.read()

                # Extract email body
                msg_body = extract_email_body(file_bytes)

                # Create output name and temp file
                base_name = os.path.splitext(os.path.basename(file_path))[0]
                output_name = f"{base_name}.txt"

                # ‚úÖ Correct usage: upload_stream(path=..., f=...)
                with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False, encoding="utf-8") as tmp_file:
                    tmp_file.write(msg_body)
                    tmp_file_path = tmp_file.name

                with open(tmp_file_path, "rb") as f:
                    output_folder.upload_stream(path=output_name, f=f)

                os.remove(tmp_file_path)
                print(f"‚úÖ Saved to Dataiku: {output_name}")

            except Exception as e:
                print(f"‚ùå Error processing {file_path}: {e}")

    else:
        print("üíª Running in Local mode...")
        os.makedirs(local_output_folder, exist_ok=True)
        files = [f for f in os.listdir(local_input_folder) if f.lower().endswith(".msg")]

        if not files:
            print("‚ö†Ô∏è No .msg files found in local input folder.")
            return

        for filename in files:
            try:
                file_path = os.path.join(local_input_folder, filename)
                msg = extract_msg.Message(file_path)
                msg_body = msg.body or msg.bodyText or ""
                msg_body = msg_body.replace("\r", "").replace("\x00", "")

                output_path = os.path.join(local_output_folder, os.path.splitext(filename)[0] + ".txt")
                with open(output_path, "w", encoding="utf-8") as f:
                    f.write(msg_body)

                print(f"‚úÖ Saved locally: {os.path.basename(output_path)}")

            except Exception as e:
                print(f"‚ùå Error processing {filename}: {e}")

    print("üéâ Conversion completed!")


# =====================================================
# üïí Run Script
# =====================================================
if __name__ == "__main__":
    start_time = datetime.now()
    print(f"üöÄ Starting MSG ‚Üí TXT conversion at {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    process_emails()
    print(f"‚è±Ô∏è Completed in {(datetime.now() - start_time).total_seconds():.2f}s")
