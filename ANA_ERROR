import dataiku
import tempfile
import os
import re
from datetime import datetime
import logging

# ------------------------------------------------------
# 🔧 Configuration
# ------------------------------------------------------
INPUT_FOLDER = dataiku.Folder("YOUR_INPUT_FOLDER_ID")
OUTPUT_FOLDER = dataiku.Folder("YOUR_OUTPUT_FOLDER_ID")

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def extract_attachments_from_msg(msg_file_path):
    """
    Extract all attachments from an MSG file using a fresh approach
    """
    try:
        # Import here to avoid dependency issues
        from msg_parser import MsOxMessage
        
        # Parse the MSG file
        msg = MsOxMessage(msg_file_path)
        attachments = []
        
        # Extract all attachments with their data
        for i, attachment in enumerate(msg.attachments):
            attachment_info = {
                'index': i + 1,
                'name': None,
                'data': None,
                'size': 0
            }
            
            # Get attachment name - try multiple possible attributes
            for attr in ['long_fname', 'filename', 'attach_long_filename']:
                if hasattr(attachment, attr):
                    name = getattr(attachment, attr)
                    if name and name.strip():
                        attachment_info['name'] = name.strip()
                        break
            
            # If no name found, create a generic one
            if not attachment_info['name']:
                attachment_info['name'] = f"attachment_{i+1}"
            
            # Get attachment data - try multiple possible attributes
            for attr in ['data', 'payload', '_get_stream_data']:
                if hasattr(attachment, attr):
                    try:
                        data = getattr(attachment, attr)
                        if callable(data):
                            data = data()
                        
                        if data and len(data) > 0:
                            attachment_info['data'] = data
                            attachment_info['size'] = len(data)
                            break
                    except:
                        continue
            
            if attachment_info['data']:
                attachments.append(attachment_info)
                logger.debug(f"Found attachment: {attachment_info['name']} ({attachment_info['size']} bytes)")
        
        return attachments
        
    except Exception as e:
        logger.error(f"Error parsing MSG file: {e}")
        return []

def get_file_extension(filename, file_data):
    """
    Determine the correct file extension
    """
    # First, try to get extension from filename
    original_ext = os.path.splitext(filename)[1].lower()
    if original_ext and len(original_ext) > 1:
        return original_ext[1:]  # Remove the dot
    
    # If no extension in filename, detect from file content
    if file_data and len(file_data) >= 8:
        file_signature = file_data[:8].hex().upper()
        
        # Common file signatures
        signatures = {
            '504B0304': 'xlsx',  # ZIP (Excel, Word, etc)
            '504B0506': 'xlsx',  # ZIP empty
            '504B0708': 'xlsx',  # ZIP spanned
            'D0CF11E0': 'xls',   # Older Office formats
            '25504446': 'pdf',   # PDF
            '89504E47': 'png',   # PNG
            'FFD8FF': 'jpg',     # JPEG
            '504B34': 'msg',     # MSG file
        }
        
        for sig, ext in signatures.items():
            if file_signature.startswith(sig):
                return ext
    
    return 'bin'  # Default extension

def clean_filename(filename):
    """
    Clean filename by removing invalid characters and normalizing
    """
    # Remove invalid characters
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    
    # Remove extra spaces and dots
    filename = re.sub(r'\s+', ' ', filename).strip()
    filename = re.sub(r'\.+', '.', filename)
    
    return filename

def extract_date_from_filename(filename):
    """
    Extract date from filename in format DD-MMM-YYYY
    """
    pattern = r'(\d{1,2}-[A-Za-z]{3}-\d{4})'
    match = re.search(pattern, filename, re.IGNORECASE)
    if match:
        return match.group(1)
    return datetime.now().strftime("%d-%b-%Y")

def process_all_msg_files():
    """
    Main function to process all MSG files in the input folder
    """
    logger.info("Starting MSG attachment extraction process")
    
    # Get all files from input folder
    try:
        all_files = INPUT_FOLDER.list_paths_in_partition()
        if not all_files:
            logger.warning("No files found in input folder")
            return 0, 0
        
        # Filter for .msg files
        msg_files = [f for f in all_files if f.lower().endswith('.msg')]
        logger.info(f"Found {len(msg_files)} MSG files to process")
        
        if not msg_files:
            logger.warning("No .msg files found in input folder")
            return 0, 0
        
    except Exception as e:
        logger.error(f"Error accessing input folder: {e}")
        return 0, 0
    
    total_files_processed = 0
    total_attachments_saved = 0
    
    # Process each MSG file
    for msg_file_path in msg_files:
        try:
            msg_filename = os.path.basename(msg_file_path)
            logger.info(f"Processing: {msg_filename}")
            
            # Extract date from filename for organization
            email_date = extract_date_from_filename(msg_filename)
            
            # Download MSG file to temporary location
            with INPUT_FOLDER.get_download_stream(msg_file_path) as stream:
                msg_content = stream.read()
            
            if not msg_content:
                logger.warning(f"Empty file: {msg_filename}")
                continue
            
            # Save to temporary file for parsing
            with tempfile.NamedTemporaryFile(delete=False, suffix='.msg') as temp_msg_file:
                temp_msg_file.write(msg_content)
                temp_msg_path = temp_msg_file.name
            
            try:
                # Extract attachments from the MSG file
                attachments = extract_attachments_from_msg(temp_msg_path)
                
                if not attachments:
                    logger.info(f"No attachments found in {msg_filename}")
                    continue
                
                logger.info(f"Found {len(attachments)} attachments in {msg_filename}")
                
                # Process each attachment
                for attachment in attachments:
                    try:
                        # Clean the attachment name
                        clean_name = clean_filename(attachment['name'])
                        
                        # Get proper file extension
                        file_extension = get_file_extension(clean_name, attachment['data'])
                        
                        # Remove any existing extension and add the correct one
                        base_name = os.path.splitext(clean_name)[0]
                        
                        # Create output filename with date prefix
                        output_filename = f"{email_date}_{base_name}.{file_extension}"
                        
                        # Ensure filename is not too long
                        if len(output_filename) > 100:
                            output_filename = f"{email_date}_attachment_{attachment['index']}.{file_extension}"
                        
                        # Upload attachment to output folder
                        OUTPUT_FOLDER.upload_stream(output_filename, attachment['data'])
                        
                        logger.info(f"Saved: {output_filename} ({attachment['size']} bytes)")
                        total_attachments_saved += 1
                        
                    except Exception as attach_error:
                        logger.error(f"Error processing attachment {attachment['name']}: {attach_error}")
                        continue
                
                total_files_processed += 1
                logger.info(f"Completed processing {msg_filename}")
                
            finally:
                # Clean up temporary file
                if os.path.exists(temp_msg_path):
                    os.remove(temp_msg_path)
            
        except Exception as file_error:
            logger.error(f"Error processing file {msg_file_path}: {file_error}")
            continue
    
    logger.info(f"Processing complete: {total_files_processed} files processed, {total_attachments_saved} attachments saved")
    return total_files_processed, total_attachments_saved

def main():
    """
    Main execution function with error handling
    """
    try:
        print("=" * 60)
        print("MSG Attachment Extractor")
        print("=" * 60)
        
        # Test folder access
        try:
            test_files = INPUT_FOLDER.list_paths_in_partition()
            print(f"📁 Input folder accessible - {len(test_files)} files found")
            
            msg_files = [f for f in test_files if f.lower().endswith('.msg')]
            print(f"📧 MSG files found: {len(msg_files)}")
            
            if not msg_files:
                print("❌ No .msg files found. Please check your input folder.")
                return
                
        except Exception as e:
            print(f"❌ Cannot access input folder: {e}")
            return
        
        # Process files
        print("\n🚀 Starting attachment extraction...")
        files_processed, attachments_saved = process_all_msg_files()
        
        print("\n" + "=" * 60)
        if files_processed > 0:
            print(f"✅ SUCCESS: Processed {files_processed} files, extracted {attachments_saved} attachments")
        else:
            print("❌ No files were processed successfully")
        print("=" * 60)
        
    except Exception as e:
        logger.error(f"Unexpected error in main execution: {e}")
        print(f"💥 Critical error: {e}")

if __name__ == "__main__":
    main()
