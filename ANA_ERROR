import os
import re
import pandas as pd
from extract_msg import Message
from io import StringIO

# ---------------------------------------------------------------------
# CONFIGURATION
# ---------------------------------------------------------------------
# If using Dataiku:
USE_DATAIKU = True

if USE_DATAIKU:
    import dataiku
    input_folder = dataiku.Folder("your_input_folder_id")
    output_folder = dataiku.Folder("your_output_folder_id")
else:
    input_folder = r"C:\path\to\input_folder"
    output_folder = r"C:\path\to\output_folder"

# Define start and end markers
start_text = "VALUES (in %)"
end_text = "Maker User No:"

# ---------------------------------------------------------------------
# FUNCTION DEFINITIONS
# ---------------------------------------------------------------------
def extract_table_from_text(text, start_marker, end_marker):
    """Extracts and parses the table between given markers."""
    # Normalize spaces
    text = re.sub(r'\s+', ' ', text)

    # Extract text between start and end markers
    pattern = re.escape(start_marker) + r'(.*?)' + re.escape(end_marker)
    match = re.search(pattern, text, re.DOTALL | re.IGNORECASE)

    if not match:
        return None

    table_text = match.group(1).strip()

    # Split into logical lines using keywords
    lines = re.split(r'(?<=\d)\s(?=[A-Za-z])|(?<=[A-Za-z])\s(?=[A-Za-z])', table_text)
    table_lines = re.split(r'(?<=\d)\s(?=[A-Za-z])|(?<=[A-Za-z])\s(?=\d)|(?<=%)\s', table_text)

    # Split the table text into lines based on likely rows
    # The table typically uses double spaces or "Bid Ask" patterns
    rows = re.split(r'(?<=\d)\s{2,}|(?<=Ask)\s', table_text)
    if len(rows) < 3:
        # Fallback split if needed
        rows = re.split(r'(?i)(?<=VOL)|(?<=RR)|(?<=STR)', table_text)

    # Split each line into columns
    data = []
    for line in rows:
        parts = re.split(r'\s{2,}|\t+', line.strip())
        if len(parts) > 1:
            data.append(parts)

    if not data:
        return None

    # Convert to DataFrame
    df = pd.DataFrame(data)
    return df


def process_msg_file(file_path_or_stream, file_name):
    """Extract the email body and parse table."""
    msg = Message(file_path_or_stream)
    body = msg.body or msg.htmlBody or ""
    if not body:
        return None

    df = extract_table_from_text(body, start_text, end_text)
    if df is not None:
        df.insert(0, "Source_File", file_name)
    return df


# ---------------------------------------------------------------------
# MAIN EXECUTION
# ---------------------------------------------------------------------
all_tables = []

if USE_DATAIKU:
    for f in input_folder.list_paths_in_partition():
        if f.lower().endswith(".msg"):
            with input_folder.get_download_stream(f) as stream:
                df = process_msg_file(stream, os.path.basename(f))
                if df is not None:
                    all_tables.append(df)
else:
    for file in os.listdir(input_folder):
        if file.lower().endswith(".msg"):
            file_path = os.path.join(input_folder, file)
            df = process_msg_file(file_path, file)
            if df is not None:
                all_tables.append(df)

# Combine all tables and save output
if all_tables:
    final_df = pd.concat(all_tables, ignore_index=True)
    if USE_DATAIKU:
        with output_folder.get_writer("extracted_table.csv") as writer:
            final_df.to_csv(writer, index=False)
    else:
        output_path = os.path.join(output_folder, "extracted_table.csv")
        final_df.to_csv(output_path, index=False)
else:
    print("⚠️ No tables found between the given markers.")
