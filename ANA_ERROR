import pandas as pd
import dataiku
import os
import io

# ------------------------------------------------------
# ⚙️ CONFIGURATION
# ------------------------------------------------------

input_folder = dataiku.Folder("INPUT_FOLDER_ID")      # 🔄 Replace with your input folder ID
output_folder = dataiku.Folder("OUTPUT_FOLDER_ID")    # 🔄 Replace with your output folder ID

# 🧠 Define custom configurations per file
file_config = {
    "file1.csv": {
        "label_column": "Label",
        "split_lengths": [2, 3],           # Normal split lengths (Remaining auto-calculated)
        "last_chars_as_remaining": 2,      # Always keep last 2 chars before '=' in Remaining
        "col_names": ["Part1", "Part2", "Remaining"]
    },
    "file2.csv": {
        "label_column": "ProductCode",
        "split_lengths": [3, 2],
        "last_chars_as_remaining": 3,
        "col_names": ["Prefix", "Batch", "Tail"]
    }
}

# Defaults (if file not in config)
default_label_column = "Label"
default_split_lengths = [2, 3]
default_last_chars_as_remaining = 2
default_col_names = ["Part1", "Part2", "Remaining"]

# ------------------------------------------------------
# 🧩 FUNCTION
# ------------------------------------------------------

def split_label(label, split_lengths, col_names, last_chars_as_remaining):
    """
    Split from left until '=' appears.
    Always reserve the last `last_chars_as_remaining` characters 
    as the final Remaining column.
    """
    label = str(label)
    
    # Stop at first '='
    if "=" in label:
        base_label = label.split("=")[0]
    else:
        base_label = label
    
    # Handle edge cases
    if not base_label:
        return dict(zip(col_names, [""] * len(col_names)))
    
    # Determine the portion excluding the last reserved part
    if len(base_label) > last_chars_as_remaining:
        core_part = base_label[:-last_chars_as_remaining]
        remaining_part = base_label[-last_chars_as_remaining:]
    else:
        core_part = ""
        remaining_part = base_label
    
    # Perform normal splits on core_part
    parts, start = [], 0
    for length in split_lengths:
        part = core_part[start:start + length]
        parts.append(part)
        start += length
    
    # Add Remaining
    parts.append(remaining_part)
    
    # Pad if short
    while len(parts) < len(col_names):
        parts.append("")
    
    return dict(zip(col_names, parts))

# ------------------------------------------------------
# 📂 PROCESS ALL FILES
# ------------------------------------------------------

file_list = input_folder.list_paths_in_partition()
print(f"Found {len(file_list)} files to process.\n")

for path in file_list:
    filename = os.path.basename(path)
    print(f"⚙️ Processing file: {filename}")

    # 🔍 Get config for file
    config = None
    for key in file_config.keys():
        if key.lower() in filename.lower():
            config = file_config[key]
            break

    if config is None:
        print(f"⚠️ No specific config for {filename}, using default settings.")
        config = {
            "label_column": default_label_column,
            "split_lengths": default_split_lengths,
            "last_chars_as_remaining": default_last_chars_as_remaining,
            "col_names": default_col_names
        }

    label_column = config["label_column"]
    split_lengths = config["split_lengths"]
    last_chars_as_remaining = config["last_chars_as_remaining"]
    col_names = config["col_names"]

    # ------------------------------------------------------
    # 📥 READ FILE
    # ------------------------------------------------------
    with input_folder.get_download_stream(filename) as f:
        if filename.lower().endswith(".csv"):
            df = pd.read_csv(f)
        elif filename.lower().endswith((".xls", ".xlsx")):
            df = pd.read_excel(f)
        else:
            print(f"⚠️ Unsupported file type, skipping: {filename}")
            continue

    # ------------------------------------------------------
    # 🧩 APPLY SPLIT LOGIC
    # ------------------------------------------------------
    if label_column not in df.columns:
        print(f"⚠️ Column '{label_column}' not found in {filename}. Skipping.")
        continue

    split_df = df[label_column].apply(
        lambda x: pd.Series(split_label(x, split_lengths, col_names, last_chars_as_remaining))
    )
    final_df = pd.concat([df, split_df], axis=1)

    # ------------------------------------------------------
    # 💾 SAVE TO OUTPUT FOLDER
    # ------------------------------------------------------
    temp_path = os.path.join("/tmp", filename)
    if filename.lower().endswith(".csv"):
        final_df.to_csv(temp_path, index=False, encoding="utf-8-sig")
    else:
        final_df.to_excel(temp_path, index=False)

    with open(temp_path, "rb") as f:
        output_folder.upload_stream(filename, f)

    print(f"✅ Saved processed file: {filename}\n")

print("🎯 All files processed successfully.")
