import re
import pandas as pd
from extract_msg import Message
from datetime import datetime
import dataiku
import os
import tempfile

# -----------------------------
# Configuration for Dataiku
# -----------------------------
# Input folder (Dataiku managed folder)
input_folder = dataiku.Folder("YOUR_INPUT_FOLDER_ID")  # replace with actual ID

# Output folder (Dataiku managed folder)
output_folder = dataiku.Folder("YOUR_OUTPUT_FOLDER_ID")  # replace with actual ID

# -----------------------------
# Utility functions
# -----------------------------
def extract_date_from_filename(filename):
    name_without_ext = os.path.splitext(filename)[0]
    patterns = [
        r'(\d{1,2}-[A-Za-z]{3}-\d{4})',
        r'(\d{1,2}(?:st|nd|rd|th)?\s+[A-Za-z]+\s+\d{4})',
        r'(\d{4}-\d{1,2}-\d{1,2})',
        r'(\d{1,2}-\d{1,2}-\d{4})'
    ]
    for pattern in patterns:
        match = re.search(pattern, name_without_ext)
        if match:
            date_str = re.sub(r'(st|nd|rd|th)', '', match.group(1))
            for fmt in ['%d-%b-%Y', '%d %B %Y', '%Y-%m-%d', '%d-%m-%Y']:
                try:
                    dt = datetime.strptime(date_str.strip(), fmt)
                    return dt.strftime('%Y-%m-%d')
                except ValueError:
                    continue
    return "unknown_date"

def extract_table_from_html(html_content):
    try:
        tables = pd.read_html(html_content)
        if tables:
            return tables[0]
    except:
        return None
    return None

def extract_table_from_text(text_content):
    lines = text_content.split('\n')
    table_data = []
    for line in lines:
        line = line.strip()
        if not line: continue
        if '\t' in line:
            row = [cell.strip() for cell in line.split('\t') if cell.strip()]
        elif ',' in line and len(line.split(',')) > 2:
            row = [cell.strip() for cell in line.split(',') if cell.strip()]
        else:
            row = [cell.strip() for cell in re.split(r'\s{2,}', line) if cell.strip()]
        if len(row) > 1:
            table_data.append(row)
    if len(table_data) > 1:
        try:
            df = pd.DataFrame(table_data[1:], columns=table_data[0])
            return df
        except:
            return None
    return None

# -----------------------------
# Core processing
# -----------------------------
def process_msg_file(msg_path, filename):
    try:
        msg = Message(msg_path)
        date_str = extract_date_from_filename(filename)

        table_df = None
        if msg.htmlBody:
            table_df = extract_table_from_html(msg.htmlBody)
        if table_df is None and msg.body:
            table_df = extract_table_from_text(msg.body)

        # Save output to Dataiku folder
        with tempfile.TemporaryDirectory() as tmp_dir:
            if table_df is not None:
                temp_file = os.path.join(tmp_dir, f"{date_str}_table.csv")
                table_df.to_csv(temp_file, index=False)
            else:
                temp_file = os.path.join(tmp_dir, f"{date_str}_raw.txt")
                with open(temp_file, "w", encoding="utf-8") as f:
                    f.write(msg.body or "")

            output_folder.upload_file(temp_file, os.path.basename(temp_file))
        return True
    except Exception as e:
        print(f"Error processing {filename}: {e}")
        return False

def process_all_msg_files():
    files_info = input_folder.list_paths_in_partition()
    msg_files = [f for f in files_info if f.lower().endswith(".msg")]
    if not msg_files:
        print("No MSG files found in input folder.")
        return

    success_count = 0
    for i, file_path in enumerate(msg_files, 1):
        print(f"[{i}/{len(msg_files)}] Processing {file_path}...")
        with input_folder.get_download_stream(file_path) as f:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".msg") as tmp_msg:
                tmp_msg.write(f.read())
                tmp_msg_path = tmp_msg.name
        if process_msg_file(tmp_msg_path, os.path.basename(file_path)):
            success_count += 1
        os.remove(tmp_msg_path)

    print(f"Processing complete! Successfully processed {success_count} of {len(msg_files)} MSG files.")

# -----------------------------
# Run
# -----------------------------
if __name__ == "__main__":
    process_all_msg_files()
