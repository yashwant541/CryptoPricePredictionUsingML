# ============================================================
#   FINAL NOMINATION CLASSIFICATION SCRIPT (FULL VERSION)
#   - Uses nominee_issues, cleaned name column
#   - Mutually exclusive Fail*Nomination categories
#   - Generates SuccessNomination, EmptyNomination
#   - Includes internal overlap check
# ============================================================

import dataiku
import pandas as pd
import re

# ------------------------------------------------------------
# READ DATASET
# ------------------------------------------------------------
df = dataiku.Dataset("AccRelNo_AgainstNominationChecks").get_dataframe()

NOM_COL = "name"
REL_COL = "relationshipno"
ACC_COL = "accountno"

# ------------------------------------------------------------
# CLEAN NAME COLUMN
# ------------------------------------------------------------
def clean_text(x):
    if x is None:
        return ""
    x = str(x)
    return re.sub(r"\s+", " ", x).strip().lower()

df["name_clean"] = df[NOM_COL].apply(clean_text)

# ------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------
RELATIONSHIP_WORDS = [
    "mother","mom","mummy","mamma","ma",
    "father","dad","daddy","papa",
    "son","daughter","child","children",
    "wife","husband","spouse",
    "brother","sister","sibling",
    "uncle","aunty","aunt","nephew","niece",
    "grandmother","grandfather","grandma","grandpa",
    "guardian","caretaker"
]

def is_one_word_name(x):
    x = str(x).strip()
    return len(x.split()) == 1 and len(x) >= 2

# ------------------------------------------------------------
# CLASSIFICATION LOGIC
# ------------------------------------------------------------
def classify_nomination(row):
    issues = row["nominee_issues"]
    raw = str(row[NOM_COL])
    name = row["name_clean"]

    # -------------------- TOP LEVEL -------------------------
    if issues == []:
        return "Success"
    if issues == ["Missing or empty name"]:
        return "Empty"

    issues_lower = [i.lower() for i in issues]

    # -------------------- PRIORITY ORDER FOR FAILS -------------------------

    # 1) U/G cases
    if "u/g" in name or "u-g" in name or "u\\g" in name:
        return "FailUG"

    # 2) SNS pattern (String String Number String) e.g., SDU NOM 123112 Ramesh
    if re.search(r"[A-Za-z]+\s+[A-Za-z]+\s+\d{2,}\s+[A-Za-z]+", raw, re.IGNORECASE):
        return "FailSNSPattern"

    forbidden_words = ["sdu", "no held", "nomheld", "held", "nominee", "nomination"]
    contains_forbidden = any(w in name for w in forbidden_words)

    # 3) NOM word + one word
    if "nom" in name and is_one_word_name(raw):
        return "FailNOMOneWord"

    # 4) Forbidden words (excluding SNS pattern and NOM one word)
    if contains_forbidden:
        return "FailForbiddenWords"

    # 5) Relationship words
    if any(rel in name for rel in RELATIONSHIP_WORDS):
        return "FailRelationship"

    # 6) NOM ending with number (like Nom123)
    if re.search(r"nom\w*\s*\d{2,}$", name):
        return "FailNOMEndingNumber"

    # 7) One-word name (fallback)
    if is_one_word_name(raw):
        return "FailOneWord"

    # 8) Digit-only name
    if re.fullmatch(r"\d+", raw.strip()):
        return "FailDigitOnly"

    # 9) Catch-all others
    return "FailOthers"

# ------------------------------------------------------------
# APPLY CLASSIFICATION
# ------------------------------------------------------------
df["NominationCase"] = df.apply(classify_nomination, axis=1)

# -------------------- CREATE SUCCESS AND EMPTY DATASETS --------------------
success_df = df[df["NominationCase"] == "Success"]
empty_df = df[df["NominationCase"] == "Empty"]

dataiku.Dataset("SuccessNomination").write_with_schema(success_df)
dataiku.Dataset("EmptyNomination").write_with_schema(empty_df)

# -------------------- FAILED BASE --------------------
fail_df = df[df["NominationCase"].str.startswith("Fail")]
dataiku.Dataset("FailAllNomination").write_with_schema(fail_df)

# -------------------- MUTUALLY EXCLUSIVE FAIL CATEGORIES --------------------
fail_categories = [
    "FailUG",
    "FailSNSPattern",
    "FailNOMOneWord",
    "FailForbiddenWords",
    "FailRelationship",
    "FailNOMEndingNumber",
    "FailOneWord",
    "FailDigitOnly",
    "FailOthers"
]

for case in fail_categories:
    dataset_name = f"{case}Nomination"
    subset = fail_df[fail_df["NominationCase"] == case]
    dataiku.Dataset(dataset_name).write_with_schema(subset)

# ------------------------------------------------------------
# FINAL INTERNAL OVERLAP CHECK
# ------------------------------------------------------------
# Combine all fail category datasets
all_fail = pd.concat([fail_df[fail_df["NominationCase"] == c] for c in fail_categories])

# Check duplicates by RelationshipNo + AccountNo
overlap_check = all_fail.groupby([REL_COL, ACC_COL]).size()
overlaps = overlap_check[overlap_check > 1]

if not overlaps.empty:
    print("⚠ Overlaps detected for RelationshipNo + AccountNo combinations:")
    print(overlaps)
else:
    print("✅ No overlaps detected. Each failed row is in exactly one category.")

# ------------------------------------------------------------
# END OF SCRIPT
# ------------------------------------------------------------
