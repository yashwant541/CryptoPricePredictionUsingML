import pandas as pd
import os
import io
import re
import dataiku

# ------------------------------------------------------
# ‚öôÔ∏è CONFIGURATION
# ------------------------------------------------------
use_dataiku = True  # üîÑ Switch between Dataiku and local

if use_dataiku:
    input_folder = dataiku.Folder("XXXXXXXX")    # Input folder = previous output (AAA, AA+ etc.)
    output_folder = dataiku.Folder("XXXXXXXX")   # Output folder for long-format CSVs
else:
    input_folder_path = r"C:\path\to\rating_level_output"
    output_folder_path = r"C:\path\to\long_output"

# ------------------------------------------------------
# üß© Helper Function: Extract date between 3rd and 4th "_"
# ------------------------------------------------------
def extract_date_from_filename(filename):
    """
    Extracts the date between the 3rd and 4th underscore ("_") in the filename.
    Expected format: 01-Aug-25 or similar.
    Returns the date string if found, else empty string.
    """
    parts = filename.split("_")
    if len(parts) >= 4:
        date_part = parts[3].split(".")[0]
        if re.match(r"\d{1,2}-[A-Za-z]{3}-\d{2,4}", date_part):
            return date_part
    return ""

# ------------------------------------------------------
# üß† FUNCTION TO PROCESS FILE
# ------------------------------------------------------
def process_file(file_path, file_name):
    df = pd.read_csv(file_path)

    # Normalize Tenor column name
    if "Tenor/Rating" in df.columns and "Tenor" not in df.columns:
        df = df.rename(columns={"Tenor/Rating": "Tenor"})
    # if neither present, try to find something with 'tenor' in name
    if "Tenor" not in df.columns:
        tenor_candidates = [c for c in df.columns if "tenor" in c.lower() or "rating" in c.lower()]
        if tenor_candidates:
            df = df.rename(columns={tenor_candidates[0]: "Tenor"})
        else:
            # create Tenor as index if not present (will become NaN)
            df["Tenor"] = pd.NA

    # Define rating columns we expect
    rating_cols = ["AAA", "AA+", "AA", "AA-"]
    category_cols = [f"{r} Category" for r in rating_cols]

    # Verify existence and log missing columns
    existing_rating_cols = [c for c in rating_cols if c in df.columns]
    existing_category_cols = [c for c in category_cols if c in df.columns]

    if not existing_rating_cols:
        print(f"‚ö†Ô∏è Skipping {file_name}: No rating columns ({rating_cols}) found.")
        return

    # Build long frames ensuring each rating picks its own category column
    long_frames = []
    for rating in rating_cols:
        rating_col = rating
        cat_col = f"{rating} Category"
        if rating_col not in df.columns:
            # skip missing rating columns
            continue

        # If category column is missing, create it with NaN to preserve structure
        if cat_col not in df.columns:
            df[cat_col] = pd.NA

        temp = df[["Tenor", rating_col, cat_col]].copy()
        temp = temp.rename(columns={rating_col: "Value", cat_col: "Category"})
        temp["Rating"] = rating
        # Reorder to a stable layout before appending
        temp = temp[["Tenor", "Rating", "Value", "Category"]]
        long_frames.append(temp)

    # Combine all into one long DataFrame
    if long_frames:
        long_df = pd.concat(long_frames, ignore_index=True)
    else:
        print(f"‚ö†Ô∏è {file_name}: No data to melt after checking rating columns.")
        return

    # Add file date from filename (same value for all rows)
    file_date = extract_date_from_filename(file_name)
    long_df["FileDate"] = file_date

    # Ensure final column order
    final_cols = ["Tenor", "Rating", "Value", "Category", "FileDate"]
    long_df = long_df[final_cols]

    # Output file name
    output_file_name = os.path.splitext(file_name)[0] + "_long.csv"

    # Save output
    if use_dataiku:
        buffer = io.StringIO()
        long_df.to_csv(buffer, index=False)
        output_folder.upload_stream(output_file_name, io.BytesIO(buffer.getvalue().encode("utf-8")))
    else:
        os.makedirs(output_folder_path, exist_ok=True)
        long_df.to_csv(os.path.join(output_folder_path, output_file_name), index=False)

    print(f"‚úÖ {file_name}: {len(long_df)} rows processed (Date: {file_date or 'N/A'})")


# ------------------------------------------------------
# üöÄ MAIN EXECUTION
# ------------------------------------------------------
if use_dataiku:
    for path in input_folder.list_paths_in_partition():
        if path.endswith(".csv"):
            file_name = os.path.basename(path)
            with input_folder.get_download_stream(path) as f:
                df = pd.read_csv(f)
                temp_path = f"/tmp/{file_name}"
                df.to_csv(temp_path, index=False)
                process_file(temp_path, file_name)
else:
    for filename in os.listdir(input_folder_path):
        if filename.endswith(".csv"):
            process_file(os.path.join(input_folder_path, filename), filename)
