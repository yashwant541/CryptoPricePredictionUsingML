import dataiku
import re
import io
import os
from datetime import datetime
import pandas as pd
from dateutil import parser

# -------------------------------
# ðŸ”§ Global variables (changeable)
# -------------------------------
START_TEXT = "TEXT"   # First cell of table; included
END_TEXT   = "TEST"   # Marks end of table; excluded

INPUT_FOLDER_ID = "INPUT_FOLDER_ID"   # Replace with your input folder ID
OUTPUT_FOLDER_ID = "OUTPUT_FOLDER_ID" # Replace with your output folder ID

# -------------------------------
# Dataiku folders
# -------------------------------
input_folder = dataiku.Folder(INPUT_FOLDER_ID)
output_folder = dataiku.Folder(OUTPUT_FOLDER_ID)

# -------------------------------
# Regex to match dates in filename
# -------------------------------
date_pattern = re.compile(
    r'(\d{1,2}(?:st|nd|rd|th)?[- ]?[A-Za-z]{3,9}[- ]\d{4}|\b\d{6}\b)',
    re.IGNORECASE
)

# -------------------------------
# Normalize date
# -------------------------------
def normalize_date(date_str):
    try:
        date_str = re.sub(r'(st|nd|rd|th)', '', date_str, flags=re.IGNORECASE)
        dt = parser.parse(date_str, dayfirst=True)
        return dt.strftime("%d-%b-%Y")
    except Exception:
        return date_str

# -------------------------------
# Extract table between START_TEXT (inclusive) and END_TEXT (exclusive)
# -------------------------------
def extract_table_from_text(text_content):
    # Split by lines
    lines = [line.strip() for line in text_content.splitlines() if line.strip()]
    
    # Find start and end line indices
    start_idx = None
    end_idx = None
    for i, line in enumerate(lines):
        if START_TEXT in line and start_idx is None:
            start_idx = i
        if END_TEXT in line and start_idx is not None:
            end_idx = i
            break
    
    if start_idx is None:
        return None  # start text not found
    
    # If END_TEXT not found, take until the end of file
    end_idx = end_idx if end_idx is not None else len(lines)
    
    # Extract table lines
    table_lines = lines[start_idx:end_idx]
    table_block = "\n".join(table_lines)
    
    # Try comma, tab, or fixed-width
    for sep in [',', '\t']:
        try:
            df = pd.read_csv(io.StringIO(table_block), sep=sep)
            if df.shape[1] > 1:
                return df
        except Exception:
            pass
    try:
        df = pd.read_fwf(io.StringIO(table_block))
        if df.shape[1] > 1:
            return df
    except Exception:
        pass
    
    return None

# -------------------------------
# Process TXT files
# -------------------------------
all_files = input_folder.list_paths_in_partition()
txt_files_found = False

for file_info in all_files:
    if not file_info.lower().endswith(".txt"):
        continue

    txt_files_found = True
    try:
        # Read TXT content
        with input_folder.get_download_stream(file_info) as f:
            txt_bytes = f.read()
            txt_content = txt_bytes.decode('utf-8', errors='ignore')

        # Extract date from filename
        match = date_pattern.search(file_info)
        file_date = normalize_date(match.group(0)) if match else "UnknownDate"

        # Extract table
        table_df = extract_table_from_text(txt_content)

        # Save table as CSV
        if table_df is not None:
            table_name = f"{file_date}_table.csv"
            with output_folder.get_upload_stream(table_name) as out_f:
                out_f.write(table_df.to_csv(index=False).encode('utf-8'))
            print(f"Saved table {table_name} from {file_info}")
        else:
            print(f"No table found in {file_info}")

    except Exception as e:
        print(f"Failed to process {file_info}: {e}")

if not txt_files_found:
    print("No TXT files found in the input folder.")
