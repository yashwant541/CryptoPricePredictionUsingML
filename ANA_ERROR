import pandas as pd
import dataiku
import tempfile
import os
from datetime import datetime

# ------------------------------------------------------
# üîß Configuration ‚Äî Replace with your Dataiku folder IDs
# ------------------------------------------------------
input_folder = dataiku.Folder("XXXXXXXX")       # üì• Input folder
output_folder = dataiku.Folder("XXXXXXXX")      # üì§ Output folder

# List of sheet names to skip
EXCEPTION_SHEETS = ["Tracking Sheet", "FXO VOLS FBIL Realtime", "FXO VOLS Refinitiv Realtime"]

# List of special filenames (partial match allowed) to apply Bid/Ask logic
SPECIAL_BID_ASK_FILES = ["IN"]


# ------------------------------------------------------
# üß† Helper Functions
# ------------------------------------------------------
def looks_like_date(val):
    """Check if a value looks like a date"""
    if isinstance(val, (pd.Timestamp, datetime)):
        return True
    if isinstance(val, str):
        for fmt in ("%d-%b-%y", "%d-%b-%Y", "%Y-%m-%d", "%m/%d/%Y", "%m-%d-%Y"):
            try:
                datetime.strptime(val.strip(), fmt)
                return True
            except:
                continue
    return False


def read_excel_safe(file_path):
    """Read Excel using openpyxl engine for .xlsx"""
    return pd.ExcelFile(file_path, engine="openpyxl")


# ------------------------------------------------------
# üß© Custom logic for IN-type (Bid/Ask) files
# ------------------------------------------------------
def process_in_type_file(tmp_path, file_name):
    xls = read_excel_safe(tmp_path)
    all_data = []  # collect data from all sheets into one CSV

    for sheet_name in xls.sheet_names:

        if sheet_name in EXCEPTION_SHEETS:
            print(f"‚è© Skipping sheet '{sheet_name}' (exception list)")
            continue

        df_raw = pd.read_excel(tmp_path, sheet_name=sheet_name, header=None, engine="openpyxl")

        # Header at row index 8, data starts at index 9
        header_row_index = 8
        data_start_index = 9
        df_data = df_raw.iloc[data_start_index:].reset_index(drop=True)
        header_row = df_raw.iloc[header_row_index]

        num_cols = df_data.shape[1]
        col = 0
        chunks = []

        while col < num_cols:
            # Skip empty columns
            if col + 2 >= num_cols:
                break

            # Identify possible Date/Bid/Ask block
            possible_date_col = df_data.iloc[:, col]
            if not possible_date_col.notna().any():
                col += 1
                continue

            # Extract three-column block
            block = df_data.iloc[:, col:col + 3].copy()
            block.columns = ["Date", "Bid", "Ask"]

            # Try to get label from row above header
            label_row_index = header_row_index - 1
            label = None
            if label_row_index >= 0 and col < df_raw.shape[1]:
                label = df_raw.iloc[label_row_index, col]
            if not isinstance(label, str) or label.strip() == "":
                label = header_row[col] if pd.notna(header_row[col]) else "Unknown Label"

            # Clean and compute average
            block["Bid"] = pd.to_numeric(block["Bid"], errors="coerce")
            block["Ask"] = pd.to_numeric(block["Ask"], errors="coerce")
            block["Value"] = (block["Bid"] + block["Ask"]) / 2
            block["Value"] = block["Value"].round(4)

            # Keep only valid rows
            block = block[block["Date"].notna() & block["Value"].notna()]
            if block.empty:
                col += 1
                continue

            # Build final structure
            temp_df = pd.DataFrame({
                "Date": pd.to_datetime(block["Date"], errors="coerce"),
                "Label": label,
                "Value": block["Value"]
            }).dropna(subset=["Date"])

            chunks.append(temp_df)
            col += 4  # skip separator blank column

        if not chunks:
            print(f"‚ö†Ô∏è No valid Bid/Ask blocks found in sheet '{sheet_name}' of {file_name}")
            continue

        combined = pd.concat(chunks, ignore_index=True)
        all_data.append(combined)

    if not all_data:
        print(f"‚ö†Ô∏è No valid data found for special file: {file_name}")
        return

    final_df = pd.concat(all_data, ignore_index=True)
    final_df = final_df.sort_values("Date").reset_index(drop=True)

    # Save single CSV for entire file
    safe_file_name = os.path.splitext(file_name)[0]
    output_name = f"{safe_file_name}.csv"

    with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False, newline='', encoding="utf-8") as tmp_file:
        final_df.to_csv(tmp_file.name, index=False)
        with open(tmp_file.name, "rb") as f:
            output_folder.upload_stream(output_name, f)
        os.remove(tmp_file.name)

    print(f"‚úÖ Special Bid/Ask file '{file_name}' saved as single CSV: {output_name}")


# ------------------------------------------------------
# üöÄ Main Execution (original logic retained)
# ------------------------------------------------------
def main():
    input_files = input_folder.list_paths_in_partition()
    if not input_files:
        raise FileNotFoundError("‚ùå No files found in input folder!")

    for excel_file_info in input_files:
        file_name = os.path.basename(excel_file_info)
        print(f"\nüìò Processing file: {file_name}")

        with input_folder.get_download_stream(excel_file_info) as stream:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
                tmp.write(stream.read())
                tmp_path = tmp.name

        # Apply special logic for IN-type (Bid/Ask) files
        if any(tag in file_name for tag in SPECIAL_BID_ASK_FILES):
            process_in_type_file(tmp_path, file_name)
            os.remove(tmp_path)
            continue

        # ---------- Original Logic ----------
        xls = read_excel_safe(tmp_path)
        for sheet_name in xls.sheet_names:
            if sheet_name in EXCEPTION_SHEETS:
                print(f"‚è© Skipping sheet '{sheet_name}' as it is in the exception list")
                continue

            df_raw = pd.read_excel(tmp_path, sheet_name=sheet_name, header=None, engine="openpyxl")

            # Row 7 (index 6) contains labels
            label_row_index = 6
            labels_row = df_raw.iloc[label_row_index]
            tidy_data_list = []

            for col in range(df_raw.shape[1]):
                label = labels_row[col]
                if pd.notna(label):
                    if col + 1 < df_raw.shape[1]:
                        dates = df_raw.iloc[label_row_index + 1:, col]
                        values = df_raw.iloc[label_row_index + 1:, col + 1]
                        mask = dates.notna() & values.notna()
                        dates = dates[mask]
                        values = values[mask]

                        temp_df = pd.DataFrame({
                            "Date": dates,
                            "Label": label,
                            "Value": values
                        })
                        tidy_data_list.append(temp_df)

            if not tidy_data_list:
                print(f"‚ö†Ô∏è No valid data found in sheet '{sheet_name}'")
                continue

            final_df = pd.concat(tidy_data_list, ignore_index=True)
            final_df["Date"] = pd.to_datetime(final_df["Date"], errors='coerce')
            final_df = final_df.sort_values("Date").reset_index(drop=True)

            safe_sheet_name = "".join(c if c.isalnum() else "_" for c in sheet_name)
            with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False, newline='', encoding="utf-8") as tmp_file:
                final_df.to_csv(tmp_file.name, index=False)
                with open(tmp_file.name, "rb") as f:
                    output_folder.upload_stream(f"{safe_sheet_name}.csv", f)
                os.remove(tmp_file.name)

            print(f"‚úÖ Sheet '{sheet_name}' saved as CSV: {safe_sheet_name}.csv")

        os.remove(tmp_path)
        print(f"‚úÖ Processing complete for file: {file_name}")


# ------------------------------------------------------
if __name__ == "__main__":
    main()
